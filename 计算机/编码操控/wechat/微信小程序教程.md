---
title: 微信小程序教程
---

开放社区
https://developers.weixin.qq.com/community/minihome/question/1366094922130079745

# 基础
## 注册小程序

单独注册小程序：每注册一个小程序都需要支付300元认证费。  
复用公众号资料注册小程序：不需支付300元公众号认证费，就可以直接免费注册小程序10个（认证的订阅号和认证的服务号都可用）。  

## 开发流程  
 - 1. 有一个邮箱
 - 2. 用邮箱注册小程序账号，并且获取微信小程序AppID
 - 3. 用注册的小程序账号登录微信公众平台
 - 4. 完善小程序信息并且添加开发者（至少一个）, 绑定接口 (开发- 开发管理-开发设置-服务器域名)
 - 5. 在微信web开发者工具上开发小程序
 - 6. 微信公众号与微信小程序绑定
 - 7. 发布小程序代码
 - 8. 提交审核

不同微信应用关联同一账号  (微信开放平台)
> 需要在微信开放平台( https://open.weixin.qq.com/) 新建安卓应用，苹果应用,把服务号和小程序绑定进来。
> 需在项目上线前操作，不然同一个微信用户会生成多个账号。

## 小程序适配方案: rpx (responsive pixel)

>规定: 任何屏幕下宽度为 750rpx
>为了定义设备的一致性，微信设定死的固定宽度 为 750rpx (响应式像素单位)，在不同宽度要进行换算.
> iphone6 下 的物理像素750×1334

# 开发流程 
> 使用 MVC 模块 分开开发

## 配置小程序
>  app.json

### pages 配置可访问的页 

### window 配置状态栏、导航条、标题、窗口背景色

```json 
      "window": {
          //背景
          "backgroundTextStyle": "light",
          "navigationBarBackgroundColor": "#fff",
          //标题
          "navigationBarTitleText": "Weixin",
          "navigationBarTextStyle": "black",
          //允许下拉刷新
          "enablePullDownRefresh": true,
          //允许上拉加载，然后内容够多，能够溢出 "height:100vh"
          "onReachBottomDistance": 50 ,//默认值是50
          // 屏幕旋转 landscape 横屏
          "pageOrientation": "auto"
          //在ipad 上启用屏幕旋转支持 
          "resizable": true
      },
```

### tabBar 配置菜单选项 ，最多5个 tab
> 图标尺寸 ,推荐 64 * 64 以下
```json
 "tabBar": {
        "color": "#6e6d6b",
        "selectedColor": "#e64340",
        "borderStyle": "white",
        "backgroundColor": "#fff",
        "list": [
            {
                "pagePath": "pages/shop/shops/index",
                "iconPath": "images/nav/home-off.png",
                "selectedIconPath": "images/nav/home-on.png",
                "text": "首页"
            }, {
        "pagePath": "pages/view/index",
        "text": "末页",
        "iconPath":"public/images/shopping.png"
      }
      ]}
``` 

### networkTimeout 设置各种网络请求的超时时间，默认 60秒

- request
- connectSocket
- uploadFile
- downloadFile

### debug 开启调试
- "debug":true

## 配置页面索引规则
> 建立索引的小程序的页面将可能展示在 搜索 结果中
> 配置 path/to/page 页面被索引，其余页面不被索引
> 页面收录设置: 可对整个小程序的索引进行关闭，小程序管理后台-功能-页面内容接入-页面收录开关
> sitemap.json 配置 

```json
  {
    "rules":[{
      "action": "allow",
      "page": "path/to/page"
    }, {
      "action": "disallow",
      "page": "#"
    }]
  }
```

## 逻辑层

> 在 iOS 上，小程序的 JS 代码运行在 JavaScriptCore
> 在 Android 上，小程序的 JS 代码通过 XS 内核来解析
> 在开发工具上 ，小程序的 JS 代码运行在 nwjs ( Chrome 内核）中

### 注册程序 App() 
> 微信小程序提供了全局的 getApp()函数，可以获取到小程序实例，在定义了 App 的函数中，使this 即可获得实例
> 注意： App()必须在 app.js 中注册，且不能注册多个

```js
       App({
         onLaunch (options) {
           // Do something initial when launch.
           //启动事件
         },
         onShow (options) {
           // Do something when show.
           // 页面显示事件
         },
         onHide () {
           // Do something when hide.
           //隐藏事件
         },
         onError (msg) {
           console.log(msg)
           // 发生错误事件
         },
         // app 对象包含的数据 
         globalData: 'I am global data'
       })
```
### 注册页面 Page({})

```js
  Page({
      data: {
          text: "This is page data."
      },
      onLoad: function(options) {
          // 页面创建时执行
      },
      onShow: function() {
          // 页面出现在前台时执行
      },
      onReady: function() {
          // 页面首次渲染完毕时执行
      },
      onHide: function() {
          // 页面从前台变为后台时执行
      },
      onUnload: function() {
          // 页面销毁时执行
      },
      onPullDownRefresh: function() {
          // 触发下拉刷新时执行
      },
      onReachBottom: function() {
          // 页面触底时执行
      },
      onShareAppMessage: function () {
          // 页面被用户分享时执行
      },
      onPageScroll: function() {
          // 页面滚动时执行
      },
      onResize: function() {
          // 页面尺寸变化时执行
      },
      onTabItemTap(item) {
          // tab 点击时执行
          console.log(item.index)
          console.log(item.pagePath)
          console.log(item.text)
      },
      // 事件响应函数
      viewTap: function() {
          this.setData({
              text: 'Set some data for updating view.'
          }, function() {
              // this is setData callback
          })
      },
      // 自由数据
      customData: {
          hi: 'MINA'
      }
  })
``` 


### 在页面中使用行为 behaviors 

```js
  // my-behavior.js
  module.exports = Behavior({
      data: {
          sharedText: 'This is a piece of data shared between pages.'
      },
      methods: {
          sharedMethod: function() {
              this.data.sharedText === 'This is a piece of data shared between pages.'
          }
      }
  })

```

```js
  // page-a.js
  var myBehavior = require('./my-behavior.js')
  Page({
      behaviors: [myBehavior],
      onLoad: function() {
          this.data.sharedText === 'This is a piece of data shared between pages.'
      }
  })
       
```
### 使用组件 Component 
``` js
    Component({
        data: {
            text: "This is page data."
        },
        methods: {
            onLoad: function(options) {
                // 页面创建时执行
            },
            onPullDownRefresh: function() {
                // 下拉刷新时执行
            },
            // 事件响应函数
            viewTap: function() {
                // ...
            }
        }
    })
 ```     
      
### 模块化

 ```js
  // common.js
  function sayHello(name) {
      console.log(Hello ${name} !)
  }
  function sayGoodbye(name) {
      console.log(Goodbye ${name} !)
  }
  
  module.exports.sayHello = sayHello
  exports.sayGoodbye = sayGoodbye
  ```

在需要使用这些模块的文件中，使用 require 将公共代码引入

 ```js
         var common = require('common.js')
         Page({
           helloMINA: function() {
             common.sayHello('MINA')
           },
           goodbyeMINA: function() {
             common.sayGoodbye('MINA')
           }
         })
```

## 视图层

### WXML 

#### 数据绑定 {{}}

> WXML 中的动态数据均来自对应 page 中的 data

<view> {{message}} </view>
#### 运算 {{}} 
>可以在{{}}内进行简单的运算，如算数运算 字符串运算、 元运算、逻辑判断、数据路径运算

#### 条件渲染 wx:if

<view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
<view wx:elif="{{view == 'APP'}}"> APP </view>
<view wx:else="{{view == 'MINA'}}"> MINA </view>

#### 包装元素 block
>block 并不是一个纽件，它仅仅是一个包装元素，不会在页函中做任何 染，只接受控制属性

#### 双向绑定语法
<input model:value="{{value}}" />

#### 在自定义组件中传递双向绑定
     双向绑定同样可以使用在自定义组件上。如下的自定义组件：
```js
         // custom-component.js
         Component({
           properties: {
             myValue: String
           }
         })
 ```          
``` html
  <!-- custom-component.wxml -->
  <input model:value="{{myValue}}" />
```      

这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value属性上。
这样，如果页面这样使用这个组件：

  <custom-component model:my-value="{{pageValue}}" />

#### 在自定义组件中触发双向绑定更新

自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData设置自身的属性。
```js
  // custom-component.js
  Component({
      properties: {
          myValue: String
      },
      methods: {
          update: function() {
              // 更新 myValue
              this.setData({
                  myValue: 'leaf'
              })
          }
      }
  })
  ``` 

如果页面这样使用这个组件：
<custom-component model:my-value="{{pageValue}}" />


当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=也会同时变
更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。

#### 列表渲染 wx:for

<view wx:for="{{array}}" wx:for-item="i"> {{i}} </view>
<text wx:for="{{[3,4,5]}}">{{index}}{{item}}</text>

#### wx:key 指定列表中项目的唯一的标识符
#### 模板 
> 一处页面代码多处使用

```html
  <template name="staffName">
    <view>
      FirstName: {{firstName}}, LastName: {{lastName}}
    </view>
  </template>

  <template is="staffName" data="{{...staffA}}"></template>
  <template is="staffName" data="{{...staffB}}"></template>
  <template is="staffName" data="{{...staffC}}"></template>
``` 

 ``` js
  Page({
      data: {
          staffA: {firstName: 'Hulk', lastName: 'Hu'},
          staffB: {firstName: 'Shang', lastName: 'You'},
          staffC: {firstName: 'Gideon', lastName: 'Lin'}
      }
  })
``` 

#### 引用模板 
> wxml 提供两种文件引用方式 impo此和 include

<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>

<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>

引入文件
<include src="../common/head.wxml" />

> include 可以将目标文件除了<template/>的整个代码引人，相当于是复制到 include 位置

### WXSS 

     
#### 样式导入 

```css
  /## common.wxss ##/
  .small-p {
      padding:5px;
  }

  /## app.wxss ##/
  @import "common.wxss";
  .middle-p {
      padding:15px;
  }
``` 

#### 导入 WeUI 样式
https://github.com/Tencent/weui-wxss.git
方式1. 把 weui.wxss 改为全局样式

方式2. 引入 json ，单会失去点击效果
```js
    "useExtendedLib": {
        "kbone": true,
        "weui": true
    }
``` 

# 组件 
## 视图组件

### 视图容器(view)

- hover-class 指定按下去的样式类 (点击效果)
- hover-start-time 按住后多久出现点击态，单位毫秒 50
- hover-stay-time	手指松开后点击态保留时间，单位毫秒	400		


### 可滚动视图区域 (scroll-view)

```html
<scroll-view scroll-y="true" style="height: 300rpx;" bindscrolltoupper="upper" bindscrolltolower="lower" bindscroll="scroll" scroll-into-view="{{toView}}" scroll-top="{{scrollTop}}">
  <view id="demo1" class="scroll-view-item demo-text-1"></view>
  <view id="demo2"  class="scroll-view-item demo-text-2"></view>
  <view id="demo3" class="scroll-view-item demo-text-3"></view>
</scroll-view>
```     
   
   | 属性        | 说明               |
   | scroll-x    | 允许横向滚动       |
   | scroll-y    | 允许纵向滚动       |
   | scroll-top  | 设置竖向滚动条位置 |
   | scroll-left | 设置横向滚动条位置 |

>横向滚动无效:
给scroll-view 加以下样式  width: 100%;white-space: nowrap;  子元素display：inline-block；

### 滑动界面 (swiper)

>内部只可放置swiper-item组件，否则会导致未定义的行为

## 基础内容
### 小图标 ( icon )
  <icon type="success_no_circle" size="50"></icon>

| 属性  | 说明                                                                                                 |
| type  | icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size  | icon的大小，单位默认为px，2.4.0起支持传入单位(rpx/px)，2.21.3起支持传入其余单位(rem 等)。            |
| color | icon的颜色，同css的color                                                                             |

### 文本组件 (text)

space 显示连续空格， 合法值为 
- ensp	中文字符空格一半大小
- emsp	中文字符空格大小
- nbsp	根据字体设置的空格大小

### 进度条 (process)
 <progress percent="40" active stroke-width="3" />

- percent 百分比 0~100
- show-info 在进度条有似lj显示百分比
- stroke-width 进皮条线的宽度,单位 px
- active  进皮条从左往右的动画

## 表单组件 

表单提交 
```
<form bindsubmit="formSubmit" >
<button form-type="submit" size="mini">提交</button>

console.log(e.detail.value.username)
console.log(e.detail.value.password)
 ```  
### button

| 属性        | 说明                                                                                           |
| size        | 按钮大小 (default 默认大小 , mini  小尺寸)                                                     |
| type        | 按钮样式 ( primary  绿色 , default 白色 , warn 红色)                                           |
| loading     | 名称前是否带 loading 图标                                                                      |
| form-type   | 用于 form 组件，点击分别会触发 form 组件的 submit/reset 事件 (submit 提交表单, reset 重置表单) |
| open-type   | 微信开放能力                                                                                   |
| hover-class | 指定按钮按下去的样式类。当 hover-class="none" 时，没有点击态效果                             |



### checkbox

  <checkbox-group>
        <label wx:for="{{array}}" wx:for-item="item" wx:key="{{item.id}}">
            <checkbox value="{{item.value}}" /> {{item.name}}
        </label>
    </checkbox-group>

### form


### input
- value 初始化内容
- type text, number, idcard , digit
- password 是否密码类型
- placeholder 提示符
- maxlength 输入最大长度
- bindinput 键入事件
- bindfocus 聚焦事件
- bindblur 失去焦点事件
### label
### 滚动选择器 picker
- mode  select 普通选择器 , time 时间选择器 , 
### radio
### 滑动选择器 slider
<slider class="" min="0" max="100" step="6" disabled="{{false}}" value="30" show-value="{{true}}" 
    backgroundColor="#e9e9e9" block-size="28" block-color="#ffffff" bindchanging="" bindchange="">
</slider>


### 开关选择器 switch
<switch class="" checked="{{false}}" type="switch|checkbox" bindchange="">
</switch>


### 文本框控件 textarea

## 导航 

### navigator
> 只支持小程序中的内部页面跳转

- url 应用内的跳转链接
- redirect  是否关闭 当前页面 ,相当于重定向

<navigator url="diary?id={ {item.id}}" hover-class="navigator-hover">
在 跳转页面的 onLoad:function(options){} 中，使用 options.id 获取 id 参数
> 注意 ： 是 onLoad ，大写的 L

## 媒体组件

### 音频组件 audio (不再维护)

<audio id="" src="https://sis-sample-audio.obs.cn-north-1.myhuaweicloud.com/16k16bit.mp3" loop="false" controls="false" poster="" name="未知音频" author="未知作者" 
    binderror="" bindplay="" bindpause="" bindtimeupdate="" bindended="">
</audio>

### image

<image class="" src="{{imagePath}}" mode="aspectFill" lazy-load="false"></image>

mode 显示模式 
- aspectFit(完整显示)
- aspectFill(水平或垂直完整)
- widthFix()
- center 不缩放阁片,只显示图片的中 间 区域
- top left  不缩放图片,只显示图 片的左上边区域

### video
<video class="" src="http://vjs.zencdn.net/v/oceans.mp4" initial-time="0" autoplay="false" loop="false" muted="false" direction="0" 
    bindplay="" bindpause="" bindended="" bindtimeupdate="" bindwaiting="" binderror="">
</video>

- controls 是否显示默认播放控件(播放/暂停按钮 、 播放进度 、 时间)
- autoplay   是否自动播放    
- danmu-list 弹幕列表
## 地图 

### map
- longitude 中心经度
- latitude 中心纬度
- scale 缩放级别 ,默认 16
- markers 标记点
- covers 覆盖物

标记点的属性
- latitude 纬度  范围 -90~90
- longitude 经度  范围 -180~180
- name 标注点名
- desc 标注点详细描述

覆盖物的属性

- latitude 纬度
- longitude 经度  范围 -180~180
- iconPath 显示的图标
- rotate 顺时针旋转角度 0~360 ,默认为 0

<map id="" class="2" longitude="116.4040" latitude="39.9213231" scale="16" markers="" 
    bindregionchange="" bindtap="" bindupdated="" markers="{{markers}}"></map>
    
markers:
            [{
                latitude: 39.9139570000,
                longitude: 116.4040560000,
                name: '我爱祖国天安门',
                desc: ' 天安门 '
            }], 

## 画布

### canvas

## 客服会话

### contact-button

# API

## 基础
### wx.env 环境变量
### wx.canIUse 

>判断小程序的API，回调，参数，组件等是否在当前版本可用。

>使用 ${API}.${method}.${param}.${option} 或者 ${component}.${attribute}.${option} 方式来调用

参数说明

- ${API} 代表 API 名字
- ${method} 代表调用方式，有效值为return, success, object, callback
- ${param} 代表参数或者返回值
- ${option} 代表参数的可选值或者返回值的属性
- ${component} 代表组件名字
- ${attribute} 代表组件属性
- ${option} 代表组件属性的可选值

``` js
      // 对象的属性或方法
      wx.canIUse('console.log')
      wx.canIUse('CameraContext.onCameraFrame')
      wx.canIUse('CameraFrameListener.start')
      wx.canIUse('Image.src')

      // wx接口参数、回调或者返回值
      wx.canIUse('openBluetoothAdapter')
      wx.canIUse('getSystemInfoSync.return.safeArea.left')
      wx.canIUse('getSystemInfo.success.screenWidth')
      wx.canIUse('showToast.object.image')
      wx.canIUse('onCompassChange.callback.direction')
      wx.canIUse('request.object.method.GET')

      // 组件的属性
      wx.canIUse('live-player')
      wx.canIUse('text.selectable')
      wx.canIUse('button.open-type.contact')
```
### wx.base64ToArrayBuffer
>将 Base64 字符串转成 ArrayBuffer 对象

## 路由

### wx.navigateTo  保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面
```js
wx.navigateTo({
     url: /pages/my/appointDetail/index?_id=${this .data.marker.id}
 }) 
```


### wx.redirectTo 关闭当前页面，跳转到应用内的某个页面
### wx.switchTab  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
### wx.navigateBack  
>关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层

## 跳转
### wx.navigateToMiniProgram
### wx.navigateBackMiniProgram
### wx.exitMiniProgram
## 转发
### wx.updateShareMenu
### wx.showShareMenu
### wx.showShareImageMenu
### wx.shareVideoMessage
### wx.shareFileMessage
### wx.onCopyUrl
### wx.offCopyUrl
### wx.hideShareMenu
### wx.getShareInfo
### wx.authPrivateMessage

## 界面
### 交互

#### wx.showToast 显示消息提示框
#### wx.hideToast 隐藏消息提示框
#### wx.showModal ​显示模态弹窗
``` js 
  wx.showModal({
            title: '标题',
            content: '内容',
            showCancel: true,
            cancelText: '取消',
            cancelColor: '#000000',
            confirmText: '确定',
            confirmColor: '#3CC51F',
            success: (result) => {
                if (result.confirm) {
                    console.log(result.confirm)
                }
            },
        });
```

#### wx.showActionSheet 显示操作菜单
### 导航栏

#### wx.setNavigationBarTitle 动态设置当前页面的标题

#### wx.showNavigationBarLoading 在当前页面显示导航条加载动画
#### wx.hideNavigationBarLoading 隐藏导航条加载动画

### 背景
wx.setBackgroundTextStyle
wx.setBackgroundColor

### Tab Bar
wx.showTabBarRedDot
wx.showTabBar
wx.setTabBarStyle
wx.setTabBarItem
wx.setTabBarBadge
wx.removeTabBarBadge
wx.hideTabBarRedDot
wx.hideTabBar
### 下拉刷新
#### wx.startPullDownRefresh
#### onPullDownRefresh 
> 在 Page 中定义 处理函数，监听该页面用户下拉刷新事件
> Page 页中 开启 enablePullDownRefresh 

``` json
{
    "navigationBarTitleText": "下拉刷新",
    "enablePullDownRefresh": true
}
```

#### wx.stopPullDownRefresh 停止当前页面下拉刷新
        wx.stopPullDownRefresh();

### 滚动
#### wx.pageScrollTo
### 动画

#### wx.createAnimation  
>创建一个动画实例 animation。调用实例的方法来描述动画。最后通过动画实例的export 方法导出动画数据传递给组件的 animation 属性。

- animation
- 动画队列

### 绘图

#### wx.createCanvasContext
#### wx.canvasToTempFilePath
把当前画布的内容导出生成图片，并返回文件路径

### 置顶
wx.setTopBarText
### 窗口
wx.setWindowSize
wx.onWindowResize
wx.offWindowResize
## 网络

### 发起请求 wx.request({})
> 发起的是 HTTPS 请求

- url  开发者服务器接口地址
- data Object/String 请求的参数
- header    设置请求的 header, header 中 不能设置 Referer
- method  OPTIONS 、 GET 、 HEAD 、 POST 、 PUT 、 DELETE 、 TRACE
- dataType   默认为 json , 会尝试对响应的数据做一次JSON .parse 
- success  收到开发者服务器成功返回的回调函数, res={data :"开发者服务器返回的内容"}
- fail 接口调用失败的回调函数
- complete 接口调用结束的回调函数(调用成功、失败都会执行)

``` js
if (res.data.status == 1) {
    console.log(JSON.parse(res.data.data))
    temp_data = JSON.parse(res.data.data)
} else {
    wx.showToast({
        title: res.data.message,
        icon: "loading ",
        duration: 2000
    });
}
```

网络请求的 referer 是不可以设直的,格式固定为 https://servicewechat.com/{appid}/{version}/page-frame. html ,其中{ appid }为小程序的 appid, {version}为小程序的版本号,版本号为 0 时表示开发版 。


### 下载 
#### wx.downloadFile

>下载文件资源到本地

### 上传
#### wx.uploadFile
> 将本地资源上传到开发者服务器，通过 wx.chooseImage 的接口获取本地路径

- url 开发者服务器url
- filePath  要上传文件资源路径
- name 文件对应的key
- formData 其它额外 form data
- success/ fail/complete

### WebSocket

WebSocket protocol 是 HTML5 一种新的协议,它实现了浏览器与服务器全双工通信( full-duple ) , 一开始的握手需要借助 HTTP 请求完成 。


#### wx.connectSocket  创建一个 WebSocket 连接
- url 开发者服务器接口地址必须是 WSS 协议 ,且域名必须是后台配置的合法域名
- data 请求的数据
- header
- method 有效值为: OPTIONS 、 GET 、 HEAD 、 POST 、 PUT 、 DELETE
- success, fail,complete

``` js
  wx.connectSocket({
            url: " test .php"
        })
        wx.onSocketOpen(function (res) {
            console.log(" WebSocket 连接巳打开!")
        })
        wx.onSocketError(function (res) {
            console.log(" WebSocket 连接打开失败, 请检查!")
        })
```

#### wx.onSocketOpen   监听 WebSocket 连接打开事件
#### wx.onSocketError  监听 WebSocket 错误
#### wx.sendSocketMessage  通过 WebSocket 连接发送数据
#### wx.onSocketMessage  监听 WebSocket 接受到服务器的消息事件
#### wx.closeSocket    关闭 WebSocket 连接
#### wx.onSocketClose  监听 WebSocket 关闭

### TCP
### UDP
## 媒体
小程序可以调用 微信实现 的从本地相册选择图片，或照相，还可以操作网络上的图片
### 图片

#### wx.chooseImage  从本地相册选择图片或使用相机拍照
- count 最多可以选择的图片张数，默认9
- sizeType  original 原图 , compressed 压缩图 , 默认两者都有
- sourceType album 从相册选图 , camera 使用相机 ,默认两者都有
- success

返回: res.tempFilePaths


####  wx.previewImage 预览图片 
- Todo ??? 不会用 

- current 当前显示的图片链接，不填则是 urls 的第一张
- urls 需要预览的图片链接列表


#### wx.getImageInfo 获取图片信息
- src 图片路径，可以是临时文件路径，存储文件路径，网络图片路径

返回
``` 
errMsg: "getImageInfo:ok"
height: 277
orientation: "up"
path: "http://tmp/swErkFuHE1EN7535caeb5c8cbd96705b85b470b29835.png"
type: "png"
width: 480
```

### 录音
#### wx.startRecord  开始录音
当主动调用 wx.stopRecord ，或者录音超过1分钟时自动结束录音，返回录音文件的临时文件路径 

> 文件的临时路径，在小程序本次启动期间有用，如需持久保存，需要主动调用 wx.saveFile

         
#### wx.stopRecord  主动调用停止录音

### 音频播放控制

##### wx.playVoice    开始播放语音
> 同时只能有一首音乐正在播放
- filePath 需要播放的语音文件的路径

##### wx.pauseVoice   暂停正在播放的语音
##### wx.stopVoice    结束播放语音

### 音乐播放控制

- wx.getBackgroundAudioPlayerState  获取音乐播放状态
- wx.playBackgroundAudio  播放音乐，同时只能有一首音乐正在播放
- wx.pauseBackgroundAudio 暂停播放音乐
- wx.seekBackgroundAudio  控制音乐播放进度
- wx.stopBackgroundAudio  停止播放音乐
- wx.onBackgroundAudioPlay  监听音乐播放
- wx.onBackgroundAudioPause 监听音乐暂停
- wx.onBackgroundAudioStop  监听音乐停止

### 音频组件控制

- wx.createAudioContext 创建并返回 audio 上下文 audioContext 对象

### 视频

#### wx.chooseVideo  拍摄视频或从手机相册中选视频，返回视频的临时文件路径

- sourceType  album 从相册选择 ，默认 ['album','camera']
- maxDuration 最长拍摄是按 ，最长60秒
- camera  front 为前置，back 为后置 ，默认 back

返回
- tempFilePath 
- duration 选定视频时长
- size 视频的数据量大小
- height
- width


### 视频组件控制

#### wx.createVideoContext  创建并返回 video 上下文 videoContext 对象
videoContext 通过 videoId 跟一个 video 组件绑定，通过它可以操作一个 video组件

videoContext 对象的方法列表:
- play 播放
- pause 暂停
- seek 跳转到指定位置，单位 秒
- sendDanmu 发送弹幕， danmu 包含两个属性 , text ，color


## 文件

### wx.saveFile 保存文件到本地
- tempFilePath 需要保存的文件的临时路径
- success  返回文件的保存路径 saveFilePath

> 本地文件存储的大小限制为 10M


### wx.getSavedFileList 获取本地已保存的文件列表

返回
- errMsg 接口调用结果
- fileList 文件列表 { filePath ,createTime,size}


### wx.getSavedFileInfo 获取本地文件的文件信息

### wx.removeSavedFile 删除本地存储的文件
- filePath 需要删除的文件路径

### wx.openDocument 新开页面打开文档，支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx

- filePath 文件路径, 可以通过 downFile 获得



## 数据缓存

### wx.setStorage   
> 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口

- key 本地缓存中的指定的 key
- data 需要存储的内容 

wx.setStorage({
key:"userinfo",
data: { name:"aming",age:"38"}
})


### wx.setStorageSync 
> 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口

### wx.getStorage  从本地缓存中异步获取指定 key 对应的内容
- key 本地缓存中指定的 key
- success  返回 res={data:key 对应的内容}


### wx.getStorageSync 从本地缓存中同步获取指定 key 对应的内容
### wx.getStorageInfo 异步获取当前 storage 的相关信息
### wx.getStorageInfoSync 同步获取当前 storage 的相关信息
### wx.removeStorage  从本地缓存中异步移除指定 key
### wx.removeStorageSync  从本地缓存中同步移除指定 key
### wx.clearStorage 清理本地数据缓存
### wx.clearStorageSync 同步清理本地数据缓存


## 位置

### wx.getLocation 获取当前的地理位置、速度
>当用户离开小程序后，此接口无法调用；当用户单击 "显示在聊天顶部"时，可以继续调用

- type 默认 wgs84，返回 GPS坐标 , gcj02返回可用于 wx.openLocation 的坐标 
- altitude 传入 true 会返回高度信息，由于获取高度需要较高精确度，会减慢接口返回速度
- isHighAccuracy 开启高精度定位
- highAccuracyExpireTime 高精度定位超时时间(ms)，指定时间内返回最高精度，该值3000ms以上高精度定位才有效果

返回参数
- latitude 纬度，范围为 -90~90 ，负数为南纬
- longitude 经度, 范围为 -180~180，负数为西经
- speed 速度 ，单位 m/s
- accuracy  位置的精确度
- altitude 高度，单位 m
- verticalAccuracy 垂直精度，单位 m（Android 无法获取，返回 0）
- horizontalAccuracy 水平精度，单位 m

### wx.chooseLocation 打开地图选择位置
- latitude
- longitude 目标地经度

返回 
- name 位置名称
- address 详细地址
- latitude
- longitude 目标地经度


### wx.openLocation 使用微信内置地图查看位置
- latitude
- longitude 目标地经度

 

### wx.createMapContext 创建并返回 map 上下文 mapContext 对象

## 设备

### 系统信息

#### wx.getSystemInfo 获取系统信息

返回 

- SDKVersion: "2.19.4"
- batteryLevel: 100
- benchmarkLevel: 1
- bluetoothEnabled: true
- brand: "devtools"
- cameraAuthorized: true
- deviceOrientation: "portrait"
- devicePixelRatio: 2
- enableDebug: true
- errMsg: "getSystemInfo:ok"
- fontSizeSetting: 16
- language: "zh_CN"
- locationAuthorized: true
- locationEnabled: true
- microphoneAuthorized: true
- model: "iPhone 5"  // 手机型号
- notificationAuthorized: true
- pixelRatio: 2  // 设备像素比
- platform: "devtools"
- safeArea: {top: 20, left: 0, right: 320, bottom: 568, width: 320, …}
- screenHeight: 568
- screenWidth: 320
- statusBarHeight: 20
- system: "iOS 10.0.1"
- version: "8.0.5"
- wifiEnabled: true
- windowHeight: 504  // 窗口宽度
- windowWidth: 320   //窗口高度

#### wx.getSystemInfoSync 获取系统信息同步接口

### 网络状态

####  wx.getNetworkType 获取网络类型

返回
- networkType: "wifi"    2g 、 3g 、4g、wifi 


### 重力感应

####  wx.onAccelerometerChange  监听重力感应数据，频率：5次/秒

### 罗盘

#### wx.onCompassChange  监听罗盘数据，频率：5次/秒

### 拨打电话

#### wx.makePhoneCall  拨打电话
- phoneNumber 需要拨打的电话号码


### 扫码

#### wx.scanCode 调起客户端扫码界面，扫码成功后返回对应的结果
- onlyFromCamera: false,
- scanType: ['qrCode(二维码)','barCode(一维码)','datamatrix(Data Matrix码)','pdf417(PDF417条码)'],

返回
- result 所扫码的内容
- scanType 所扫码的类型
- charSet	所扫码的字符集
- path	当所扫的码为当前小程序二维码时，会返回此字段，内容为二维码携带的 path
- rawData 原始数据，base64编码
 
- QR_CODE	二维码
- AZTEC	一维码
- CODABAR	一维码
- CODE_39	一维码
- CODE_93	一维码
- CODE_128	一维码
## 开放接口

### 登录

####  wx.login 
>获取登录凭证（code）进而换取用户登录态信息

"021O9T100yqvGN1RvP200RqDyI3O9T1C"

- timeout:10000, 超时时间，单位ms

返回
- code 

#### code 换取 session_key
用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 auth.code2Session，
使用 code 换取 openid、unionid、session_key 等信息

``` js

wx.login({
  success (res) {
    if (res.code) {
      //发起网络请求
      wx.request({
        url: 'https://example.com/onLogin',
        data: {
          code: res.code
        }
      })
    } else {
      console.log('登录失败！' + res.errMsg)
    }
  }
})
```

接口地址如下 
https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code

请求参数

- appid	小程序 appId
- secret 小程序 appSecret
- js_code 登录时获取的 code
- grant_type 授权类型，此处只需填写 authorization_code

返回值

- openid	用户唯一标识
- session_key	会话密钥
- unionid	用户在开放平台的唯一标识符，若当前小程序已绑定到微信开放平台帐号下会返回，详见 UnionID 机制说明。
- errcode	错误码

errcode 的合法值
- -1	系统繁忙，此时请开发者稍候再试	
- 0	请求成功	
- 40029	code 无效	
- 45011	频率限制，每个用户每分钟100次	
- 40226	高风险等级用户，小程序登录拦截 

#### 登录态维护
通过 wx.login() 获取到用户登录状态后，需要维护登录态。开发者注意不应该直接把 session_key, openid 等字段作为用户的标识或 session 的标识，而应该自己派发一个 session 登录态。对于开发者自己生成的 session，应该保证其安全性且不应该设置较长的过期时间。 session 派发到小程序客户端之后，可将其存储在 storage 上，用于后续通信使用。



#### 登录时序图
> wx.checkSession 检查登陆态是否过期
>调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期

``` js
wx.checkSession({
  success () {
    //session_key 未过期，并且在本生命周期一直有效
  },
  fail () {
    // session_key 已经失效，需要重新执行登录流程
    wx.login() //重新登录
  }
})

```

#### 用户数据的签名校验
> 为了确保开放接口返回用户数据的安全性,微信会对明文数据进行签名 。 开发者可以根据业务需要对数据包进行签名校验,确保数据的完整性 。

通过调用接口(如 wx.getUserlnfo )获取数据时,接口会同时返回 rawData 、 signature ,其中 signature=sha1(rawData+session_key) 。

开发者将 signature 、 rawData 发送到开发者服务器进行校验 。 服务器利用用户对应的 session_key 使用相同的算法计算出 签名 signature2 ,比对 signature 与 signature2 即可校验数据的完整性 


#### 加密数据解密算法
接口如果涉及敏感数据(如 openId 和 unionId)，接口的明文内容将不包含这些敏感信息。开发者如需获取敏感数据，要对接口返回的加密数据 进行对称解密.

- 对称解密使用的算法为 AES-128-CBC ,数据采用 PKCS#7 填充 。
- 对称解密的目标密文为 Base64_Decode( encryptedData) 。
- 对称解密密钥 aeskey=Base64_Decode( session_key), aeskey 是 16 字节 。
- 对称解密算法初始向量 iv 会在数据接口中返回 。

### 用户信息

#### wx.getUserInfo 获取用户信息，需要先调用 wx.login 
- withCredentials 是否带上登录态信息
- lang 显示用户信息的语言  en , zh_CN, zh_TW

返回
- userInfo 用户信息对象，不包含 openid 等敏感信息
- rawData 不包括敏感信息的原始数据字符串，用于计算签名
- signature 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息
- encryptedData 包括敏感数据在内的完整用户信息的加密数据
- iv 加密算法的初始向量
- cloudID 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据
``` json
{
  "openId": "OPENID",
  "nickName": "NICKNAME",
  "gender": GENDER,
  "city": "CITY",
  "province": "PROVINCE",
  "country": "COUNTRY",
  "avatarUrl": "AVATARURL",
  "unionId": "UNIONID",
  "watermark": {
    "appid":"APPID",
    "timestamp":TIMESTAMP
  }
}
```
小程序用户信息组件示例代码
``` html
<!-- 如果只是展示用户头像昵称，可以使用 <open-data /> 组件 -->
<open-data type="userAvatarUrl"></open-data>
<open-data type="userNickName"></open-data>
<!-- 需要使用 button 来授权登录 -->
<button wx:if="{{canIUse}}" open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo">授权登录</button>
<view wx:else>请升级微信版本</view>
```

``` js
Page({
  data: {
    canIUse: wx.canIUse('button.open-type.getUserInfo')
  },
  onLoad: function() {
    // 查看是否授权
    wx.getSetting({
      success (res){
        if (res.authSetting['scope.userInfo']) {
          // 已经授权，可以直接调用 getUserInfo 获取头像昵称
          wx.getUserInfo({
            success: function(res) {
              console.log(res.userInfo)
            }
          })
        }
      }
    })
  },
  bindGetUserInfo (e) {
    console.log(e.detail.userInfo)
  }
})
```

#### UnionID 机制说明
同一用户 ,对同一个微信开放平台下的不同应用, unionid 是相同的 

### 微信支付
#### wx.requestPayment 发起微信支付
> 发起微信支付。调用前需在小程序微信公众平台 -功能-微信支付入口申请接入微信支付

- timeStamp 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间
- nonceStr 随机字符串，长度为32个字符以下
- package 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=***
- signType 签名算法，应与后台下单时的值一致 MD5,HMAC-SHA256,RSA
- paySign 签名

### 模板消息
基于微信的通知渠道，微信为开发者提供了可以高效触达用户的模板消息能力,以便实现服务
的闭环井提供更佳的体验 。

#### 使用说明
获取模板 id , 登录 https://mp.weixin.qq.com 获取模板,如果没有合适的模板,可以申请添加新
模板,审核通过后可使用,详见模板审核说明

页面的<form >组件,当属性 report-submit 为 true 时,可以声明为需发模板消息 ,此时单
击按钮提交表单可以获取 formid ,用于发送模板消息 。 当用户完成支付行为,可以获取
prepay_id 用 于发 送模板消息 。

#### 调用接口下发模板消息
(1) 获取 access_token

https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET

- grant_type 获取 access_token ,填写 client credential
- appid 第三方用户唯一凭证
- secret 即 appsecret

返回
- access_token 获取到的凭证
- expires_in 凭证有效时间,单位:秒


(2) 发送模板消息
https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=ACCESSTOKEN

POST请求
- touser  接收者(用户)的 openid
- template_id 所有需下发的模板消息的id
- form_id  表单提交场景下,为 submit 事件带上 的 formld , 支付场景下,为本次支付的 prepay_id
- value 模板内容,不填则下发空模板
- color 字体颜色
- emphasis_keyword 模板需要放大的关键词,不填则默认无放大

### 客服消息

#### 接收消息和事件
> 设置→消息服务器
##### 文本消息
##### 图片消息
##### 进入会话事件
#### 发送客服消息
#### 临时素材接口
##### 获取临时素材
##### 新增临时素材

### 分享

#### Page.onShareAppMessage
- title 分享标题
- desc 分享描述
- path 分享路径，以 /开头的完整路径

#### 获取二维码
>通过后台接口可以获取小程序任意页面的二维码,扫描该二维码可以直接进入小程序对应的页面

https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN

POST 参数
- path 不能为空 ,最大长度 128 字节
- width 二维码的宽度  ，默认 430

{"path":"pages/index?index=1","width": 430}
>带参二维码只有 100000 个,请谨慎调用 


## 获取界面上的节点信息 wx.createSelectorQuery
>用于获取节点属性、样式、在界面上的位置等信息。
>最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

```js
 const query = wx.createSelectorQuery()
 query.select('#the-id').boundingClientRect(function(res){
   res.top // #the-id 节点的上边界坐标（相对于显示区域）
 })
 query.selectViewport().scrollOffset(function(res){
   res.scrollTop // 显示区域的竖直滚动位置
 })
 query.exec()
``` 

上述示例中， #the-id 是一个节点选择器，与 CSS的选择器相近但略有区别

在自定义组件或包含自定义组件的页面中，推荐使用 this.createSelectorQuery 来代替 ，这样可以确保在正确的范围内选择节点。


# 事件
> 事件是视图层到逻辑层的通信方式
## 事件类型 
### 冒泡事件
| 类型               | 触发条件                                                          |
|--------------------+-------------------------------------------------------------------|
| touchstart         | 手指触摸动作开始                                                  |
| touchmove          | 手指触摸后移动                                                    |
| touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                              |
| touchend           | 手指触摸动作结束                                                  |
| tap                | 手指触摸后马上离开                                                |
| longpress          | 手指触摸后，超过 350ms 再离开，如果指定此事件，tap 事件将不被触发 |
| longtap            | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）      |
| transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发         |
| animationstart     | 会在一个 WXSS animation 动画开始时触发                            |
| animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                        |
| animationend       | 会在一个 WXSS animation 动画完成时触发                            |
| touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                      |

### 非冒泡事件
>如form 的 submit ，input的 input ， scroll-view 的 scroll事件

## 屏幕旋转事件     
   js
    Page({
        onResize(res) {
            res.size.windowWidth // 新的显示区域宽度
            res.size.windowHeight // 新的显示区域高度
        }
    })
  

## 事件属性
   - capture-bind：捕获阶段触发。
   - capture-catch：捕获阶段触发，并中断事件，不再向下传播，即中断捕获阶段，并取消随后的冒泡阶段。
   - bind：冒泡阶段触发。
   - catch：冒泡阶段触发，并取消事件进一步向上冒泡。

## 事件详解

### 绑定并阻止事件冒泡 catch
    
### 互斥事件绑定 mut-bind
> 所有 mut-bind是“互斥”的，只会有其中一个绑定函数被触发。
> 同时，它完全不影响 bind 和catch 的绑定效果。

例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
=handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。

``` html
 <view id="outer" mut-bind:tap="handleTap1">
   outer view
   <view id="middle" bindtap="handleTap2">
     middle view
     <view id="inner" mut-bind:tap="handleTap3">
       inner view
     </view>
   </view>
 </view>
```

### 获取属性值 
 <view class='first' data-num="1024" data-name="张三">第一个view</view>
  const first = e.currentTarget.dataset.name,
 
---
title: 微信小程序教程
---

iphone6的物理像素750×1334

开放社区
https://developers.weixin.qq.com/community/minihome/question/1366094922130079745

> 微信小程序，是微信开通的一个软件服务，需要支付一定费用

# 基础
## 注册小程序
单独注册小程序：每注册一个小程序都需要支付300元认证费。  
复用公众号资料注册小程序：不需支付300元公众号认证费，就可以直接免费注册小程序10个（认证的订阅号和认证的服务号都可用）。  

## 开发流程  
 - 1. 有一个邮箱
 - 2. 用邮箱注册小程序账号，并且获取微信小程序AppID
 - 3. 用注册的小程序账号登录微信公众平台
 - 4. 完善小程序信息并且添加开发者（至少一个）, 绑定接口 (开发- 开发管理-开发设置-服务器域名)
 - 5. 在微信web开发者工具上开发小程序
 - 6. 微信公众号与微信小程序绑定
 - 7. 发布小程序代码
 - 8. 提交审核

不同微信应用关联同一账号  (微信开放平台)
> 需要在微信开放平台( https://open.weixin.qq.com/) 新建安卓应用，苹果应用,把服务号和小程序绑定进来。
> 需在项目上线前操作，不然同一个微信用户会生成多个账号。


# 开发流程 
> MVC 分开开发

## 配置小程序
>  app.json

### pages 配置可访问的页 

### window 配置状态栏、导航条、标题、窗口背景色

```json 
      "window": {
          //背景
          "backgroundTextStyle": "light",
          "navigationBarBackgroundColor": "#fff",
          //标题
          "navigationBarTitleText": "Weixin",
          "navigationBarTextStyle": "black",
          //允许下拉刷新
          "enablePullDownRefresh": true,
          //允许上拉加载，然后内容够多，能够溢出 "height:100vh"
          "onReachBottomDistance": 50 ,//默认值是50
          // 屏幕旋转 landscape 横屏
          "pageOrientation": "auto"
          //在ipad 上启用屏幕旋转支持 
          "resizable": true
      },
```

### tabBar 配置菜单选项 ，最多5个 tab
> 图标尺寸 ,推荐 64 * 64 以下
```json
 "tabBar": {
        "color": "#6e6d6b",
        "selectedColor": "#e64340",
        "borderStyle": "white",
        "backgroundColor": "#fff",
        "list": [
            {
                "pagePath": "pages/shop/shops/index",
                "iconPath": "images/nav/home-off.png",
                "selectedIconPath": "images/nav/home-on.png",
                "text": "首页"
            }, {
        "pagePath": "pages/view/index",
        "text": "末页",
        "iconPath":"public/images/shopping.png"
      }
      ]}
``` 

### networkTimeout 设置各种网络请求的超时时间，默认 60秒

- request
- connectSocket
- uploadFile
- downloadFile

### debug 开启调试
- "debug":true

## 配置页面索引规则
> 建立索引的小程序的页面将可能展示在 搜索 结果中
> 配置 path/to/page 页面被索引，其余页面不被索引
> 页面收录设置: 可对整个小程序的索引进行关闭，小程序管理后台-功能-页面内容接入-页面收录开关
> sitemap.json 配置 

```json
  {
    "rules":[{
      "action": "allow",
      "page": "path/to/page"
    }, {
      "action": "disallow",
      "page": "#"
    }]
  }
```

## 逻辑层

> 在 iOS 上，小程序的 JS 代码运行在 JavaScriptCore
> 在 Android 上，小程序的 JS 代码通过 XS 内核来解析
> 在开发工具上 ，小程序的 JS 代码运行在 nwjs ( Chrome 内核）中

### 注册程序 App() 
> 微信小程序提供了全局的 getApp()函数，可以获取到小程序实例，在定义了 App 的函数中，使this 即可获得实例
> 注意： App()必须在 app.js 中注册，且不能注册多个

```js
       App({
         onLaunch (options) {
           // Do something initial when launch.
           //启动事件
         },
         onShow (options) {
           // Do something when show.
           // 页面显示事件
         },
         onHide () {
           // Do something when hide.
           //隐藏事件
         },
         onError (msg) {
           console.log(msg)
           // 发生错误事件
         },
         // app 对象包含的数据 
         globalData: 'I am global data'
       })
```
### 注册页面 Page({})

```js
  Page({
      data: {
          text: "This is page data."
      },
      onLoad: function(options) {
          // 页面创建时执行
      },
      onShow: function() {
          // 页面出现在前台时执行
      },
      onReady: function() {
          // 页面首次渲染完毕时执行
      },
      onHide: function() {
          // 页面从前台变为后台时执行
      },
      onUnload: function() {
          // 页面销毁时执行
      },
      onPullDownRefresh: function() {
          // 触发下拉刷新时执行
      },
      onReachBottom: function() {
          // 页面触底时执行
      },
      onShareAppMessage: function () {
          // 页面被用户分享时执行
      },
      onPageScroll: function() {
          // 页面滚动时执行
      },
      onResize: function() {
          // 页面尺寸变化时执行
      },
      onTabItemTap(item) {
          // tab 点击时执行
          console.log(item.index)
          console.log(item.pagePath)
          console.log(item.text)
      },
      // 事件响应函数
      viewTap: function() {
          this.setData({
              text: 'Set some data for updating view.'
          }, function() {
              // this is setData callback
          })
      },
      // 自由数据
      customData: {
          hi: 'MINA'
      }
  })
``` 


### 在页面中使用行为 behaviors 

```js
  // my-behavior.js
  module.exports = Behavior({
      data: {
          sharedText: 'This is a piece of data shared between pages.'
      },
      methods: {
          sharedMethod: function() {
              this.data.sharedText === 'This is a piece of data shared between pages.'
          }
      }
  })

```

```js
  // page-a.js
  var myBehavior = require('./my-behavior.js')
  Page({
      behaviors: [myBehavior],
      onLoad: function() {
          this.data.sharedText === 'This is a piece of data shared between pages.'
      }
  })
       
```
### 使用组件 Component 
``` js
    Component({
        data: {
            text: "This is page data."
        },
        methods: {
            onLoad: function(options) {
                // 页面创建时执行
            },
            onPullDownRefresh: function() {
                // 下拉刷新时执行
            },
            // 事件响应函数
            viewTap: function() {
                // ...
            }
        }
    })
 ```     
      
### 模块化

 ```js
  // common.js
  function sayHello(name) {
      console.log(Hello ${name} !)
  }
  function sayGoodbye(name) {
      console.log(Goodbye ${name} !)
  }
  
  module.exports.sayHello = sayHello
  exports.sayGoodbye = sayGoodbye
  ```

在需要使用这些模块的文件中，使用 require 将公共代码引入

 ```js
         var common = require('common.js')
         Page({
           helloMINA: function() {
             common.sayHello('MINA')
           },
           goodbyeMINA: function() {
             common.sayGoodbye('MINA')
           }
         })
```

## 视图层

### WXML 

#### 数据绑定 {{}}

> WXML 中的动态数据均来自对应 page 中的 data

<view> {{message}} </view>
#### 运算 {{}} 
>可以在{{}}内进行简单的运算，如算数运算 字符串运算、 元运算、逻辑判断、数据路径运算

#### 条件渲染 wx:if

<view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
<view wx:elif="{{view == 'APP'}}"> APP </view>
<view wx:else="{{view == 'MINA'}}"> MINA </view>

#### 包装元素 block
>block 并不是一个纽件，它仅仅是一个包装元素，不会在页函中做任何 染，只接受控制属性

#### 双向绑定语法
<input model:value="{{value}}" />

#### 在自定义组件中传递双向绑定
     双向绑定同样可以使用在自定义组件上。如下的自定义组件：
```js
         // custom-component.js
         Component({
           properties: {
             myValue: String
           }
         })
 ```          
``` html
  <!-- custom-component.wxml -->
  <input model:value="{{myValue}}" />
```      

这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value属性上。
这样，如果页面这样使用这个组件：

  <custom-component model:my-value="{{pageValue}}" />

#### 在自定义组件中触发双向绑定更新

自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData设置自身的属性。
```js
  // custom-component.js
  Component({
      properties: {
          myValue: String
      },
      methods: {
          update: function() {
              // 更新 myValue
              this.setData({
                  myValue: 'leaf'
              })
          }
      }
  })
  ``` 

如果页面这样使用这个组件：
<custom-component model:my-value="{{pageValue}}" />


当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=也会同时变
更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。

#### 列表渲染 wx:for

<view wx:for="{{array}}" wx:for-item="i"> {{i}} </view>
<text wx:for="{{[3,4,5]}}">{{index}}{{item}}</text>

#### wx:key 指定列表中项目的唯一的标识符
#### 模板 
> 一处页面代码多处使用

```html
  <template name="staffName">
    <view>
      FirstName: {{firstName}}, LastName: {{lastName}}
    </view>
  </template>

  <template is="staffName" data="{{...staffA}}"></template>
  <template is="staffName" data="{{...staffB}}"></template>
  <template is="staffName" data="{{...staffC}}"></template>
``` 

 ``` js
  Page({
      data: {
          staffA: {firstName: 'Hulk', lastName: 'Hu'},
          staffB: {firstName: 'Shang', lastName: 'You'},
          staffC: {firstName: 'Gideon', lastName: 'Lin'}
      }
  })
``` 

#### 引用模板 
> wxml 提供两种文件引用方式 impo此和 include

<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>

<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>

引入文件
<include src="../common/head.wxml" />

> include 可以将目标文件除了<template/>的整个代码引人，相当于是复制到 include 位置

### WXSS 

>为了定义设备的一致性，微信设定死的固定宽度 为 750rpx (响应式像素单位)，在不同宽度要进行换算.
     
#### 样式导入 

```css
  /## common.wxss ##/
  .small-p {
      padding:5px;
  }

  /## app.wxss ##/
  @import "common.wxss";
  .middle-p {
      padding:15px;
  }
``` 

#### 导入 WeUI 样式
https://github.com/Tencent/weui-wxss.git
方式1. 把 weui.wxss 改为全局样式

方式2. 引入 json ，单会失去点击效果
```js
    "useExtendedLib": {
        "kbone": true,
        "weui": true
    }
``` 

# 组件 
## 视图组件

### 视图容器(view)

- hover-class 指定按下去的样式类 (点击效果)
- hover-start-time 按住后多久出现点击态，单位毫秒 50
- hover-stay-time	手指松开后点击态保留时间，单位毫秒	400		


### 可滚动视图区域 (scroll-view)

```html
<scroll-view scroll-y="true" style="height: 300rpx;" bindscrolltoupper="upper" bindscrolltolower="lower" bindscroll="scroll" scroll-into-view="{{toView}}" scroll-top="{{scrollTop}}">
  <view id="demo1" class="scroll-view-item demo-text-1"></view>
  <view id="demo2"  class="scroll-view-item demo-text-2"></view>
  <view id="demo3" class="scroll-view-item demo-text-3"></view>
</scroll-view>
```     
   
   | 属性        | 说明               |
   | scroll-x    | 允许横向滚动       |
   | scroll-y    | 允许纵向滚动       |
   | scroll-top  | 设置竖向滚动条位置 |
   | scroll-left | 设置横向滚动条位置 |

>横向滚动无效:
给scroll-view 加以下样式  width: 100%;white-space: nowrap;  子元素display：inline-block；

### 滑动界面 (swiper)

>内部只可放置swiper-item组件，否则会导致未定义的行为

## 基础内容
### 小图标 ( icon )
  <icon type="success_no_circle" size="50"></icon>

| 属性  | 说明                                                                                                 |
| type  | icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size  | icon的大小，单位默认为px，2.4.0起支持传入单位(rpx/px)，2.21.3起支持传入其余单位(rem 等)。            |
| color | icon的颜色，同css的color                                                                             |

### 文本组件 (text)

space 显示连续空格， 合法值为 
- ensp	中文字符空格一半大小
- emsp	中文字符空格大小
- nbsp	根据字体设置的空格大小

### 进度条 (process)
 <progress percent="40" active stroke-width="3" />

- percent 百分比 0~100
- show-info 在进度条有似lj显示百分比
- stroke-width 进皮条线的宽度,单位 px
- active  进皮条从左往右的动画

## 表单组件 

表单提交 
```
<form bindsubmit="formSubmit" >
<button form-type="submit" size="mini">提交</button>

console.log(e.detail.value.username)
console.log(e.detail.value.password)
 ```  
### button

| 属性        | 说明                                                                                           |
| size        | 按钮大小 (default 默认大小 , mini  小尺寸)                                                     |
| type        | 按钮样式 ( primary  绿色 , default 白色 , warn 红色)                                           |
| loading     | 名称前是否带 loading 图标                                                                      |
| form-type   | 用于 form 组件，点击分别会触发 form 组件的 submit/reset 事件 (submit 提交表单, reset 重置表单) |
| open-type   | 微信开放能力                                                                                   |
| hover-class | 指定按钮按下去的样式类。当 hover-class="none" 时，没有点击态效果                             |



### checkbox

  <checkbox-group>
        <label wx:for="{{array}}" wx:for-item="item" wx:key="{{item.id}}">
            <checkbox value="{{item.value}}" /> {{item.name}}
        </label>
    </checkbox-group>

### form


### input
- value 初始化内容
- type text, number, idcard , digit
- password 是否密码类型
- placeholder 提示符
- maxlength 输入最大长度
- bindinput 键入事件
- bindfocus 聚焦事件
- bindblur 失去焦点事件
### label
### 滚动选择器 picker
- mode  select 普通选择器 , time 时间选择器 , 
### radio
### 滑动选择器 slider
<slider class="" min="0" max="100" step="6" disabled="{{false}}" value="30" show-value="{{true}}" 
    backgroundColor="#e9e9e9" block-size="28" block-color="#ffffff" bindchanging="" bindchange="">
</slider>


### 开关选择器 switch
<switch class="" checked="{{false}}" type="switch|checkbox" bindchange="">
</switch>


### 文本框控件 textarea

## 导航 

### navigator
> 只支持小程序中的内部页面跳转

- url 应用内的跳转链接
- redirect  是否关闭 当前页面 ,相当于重定向

<navigator url="diary?id={ {item.id}}" hover-class="navigator-hover">
在 跳转页面的 onLoad:function(options){} 中，使用 options.id 获取 id 参数
> 注意 ： 是 onLoad ，大写的 L

## 媒体组件

### 音频组件 audio (不再维护)

<audio id="" src="https://sis-sample-audio.obs.cn-north-1.myhuaweicloud.com/16k16bit.mp3" loop="false" controls="false" poster="" name="未知音频" author="未知作者" 
    binderror="" bindplay="" bindpause="" bindtimeupdate="" bindended="">
</audio>

### image

<image class="" src="{{imagePath}}" mode="aspectFill" lazy-load="false"></image>

mode 显示模式 
- aspectFit(完整显示)
- aspectFill(水平或垂直完整)
- widthFix()
- center 不缩放阁片,只显示图片的中 间 区域
- top left  不缩放图片,只显示图 片的左上边区域

### video
<video class="" src="http://vjs.zencdn.net/v/oceans.mp4" initial-time="0" autoplay="false" loop="false" muted="false" direction="0" 
    bindplay="" bindpause="" bindended="" bindtimeupdate="" bindwaiting="" binderror="">
</video>

- controls 是否显示默认播放控件(播放/暂停按钮 、 播放进度 、 时间)
- autoplay   是否自动播放    
- danmu-list 弹幕列表
## 地图 

### map
- longitude 中心经度
- latitude 中心纬度
- scale 缩放级别 ,默认 16
- markers 标记点
- covers 覆盖物

标记点的属性
- latitude 纬度  范围 -90~90
- longitude 经度  范围 -180~180
- name 标注点名
- desc 标注点详细描述

覆盖物的属性

- latitude 纬度
- longitude 经度  范围 -180~180
- iconPath 显示的图标
- rotate 顺时针旋转角度 0~360 ,默认为 0

<map id="" class="2" longitude="116.4040" latitude="39.9213231" scale="16" markers="" 
    bindregionchange="" bindtap="" bindupdated="" markers="{{markers}}"></map>
    
markers:
            [{
                latitude: 39.9139570000,
                longitude: 116.4040560000,
                name: '我爱祖国天安门',
                desc: ' 天安门 '
            }], 

## 画布

### canvas

## 客服会话

### contact-button

# API

## 基础
### wx.env 环境变量
### wx.canIUse 

>判断小程序的API，回调，参数，组件等是否在当前版本可用。

>使用 ${API}.${method}.${param}.${option} 或者 ${component}.${attribute}.${option} 方式来调用

参数说明

- ${API} 代表 API 名字
- ${method} 代表调用方式，有效值为return, success, object, callback
- ${param} 代表参数或者返回值
- ${option} 代表参数的可选值或者返回值的属性
- ${component} 代表组件名字
- ${attribute} 代表组件属性
- ${option} 代表组件属性的可选值

``` js
      // 对象的属性或方法
      wx.canIUse('console.log')
      wx.canIUse('CameraContext.onCameraFrame')
      wx.canIUse('CameraFrameListener.start')
      wx.canIUse('Image.src')

      // wx接口参数、回调或者返回值
      wx.canIUse('openBluetoothAdapter')
      wx.canIUse('getSystemInfoSync.return.safeArea.left')
      wx.canIUse('getSystemInfo.success.screenWidth')
      wx.canIUse('showToast.object.image')
      wx.canIUse('onCompassChange.callback.direction')
      wx.canIUse('request.object.method.GET')

      // 组件的属性
      wx.canIUse('live-player')
      wx.canIUse('text.selectable')
      wx.canIUse('button.open-type.contact')
```
### wx.base64ToArrayBuffer
>将 Base64 字符串转成 ArrayBuffer 对象

## 路由

### wx.navigateTo  保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面
```js
wx.navigateTo({
     url: /pages/my/appointDetail/index?_id=${this .data.marker.id}
 }) 
```


### wx.redirectTo 关闭当前页面，跳转到应用内的某个页面
### wx.switchTab  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
### wx.navigateBack  
>关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层

## 跳转
### wx.navigateToMiniProgram
### wx.navigateBackMiniProgram
### wx.exitMiniProgram
## 转发
### wx.updateShareMenu
### wx.showShareMenu
### wx.showShareImageMenu
### wx.shareVideoMessage
### wx.shareFileMessage
### wx.onCopyUrl
### wx.offCopyUrl
### wx.hideShareMenu
### wx.getShareInfo
### wx.authPrivateMessage

## 界面
### 交互

#### wx.showToast 显示消息提示框
#### wx.hideToast 隐藏消息提示框
#### wx.showModal ​显示模态弹窗
``` js 
  wx.showModal({
            title: '标题',
            content: '内容',
            showCancel: true,
            cancelText: '取消',
            cancelColor: '#000000',
            confirmText: '确定',
            confirmColor: '#3CC51F',
            success: (result) => {
                if (result.confirm) {
                    console.log(result.confirm)
                }
            },
        });
```

#### wx.showActionSheet 显示操作菜单
### 导航栏

#### wx.setNavigationBarTitle 动态设置当前页面的标题

#### wx.showNavigationBarLoading 在当前页面显示导航条加载动画
#### wx.hideNavigationBarLoading 隐藏导航条加载动画

### 背景
wx.setBackgroundTextStyle
wx.setBackgroundColor

### Tab Bar
wx.showTabBarRedDot
wx.showTabBar
wx.setTabBarStyle
wx.setTabBarItem
wx.setTabBarBadge
wx.removeTabBarBadge
wx.hideTabBarRedDot
wx.hideTabBar

### 下拉刷新
#### wx.startPullDownRefresh
#### onPullDownRefresh 
> 在 Page 中定义 处理函数，监听该页面用户下拉刷新事件
> Page 页中 开启 enablePullDownRefresh 

``` json
{
    "navigationBarTitleText": "下拉刷新",
    "enablePullDownRefresh": true
}
```

#### wx.stopPullDownRefresh 停止当前页面下拉刷新
        wx.stopPullDownRefresh();

### 滚动
#### wx.pageScrollTo
### 动画

#### wx.createAnimation  
>创建一个动画实例 animation。调用实例的方法来描述动画。最后通过动画实例的export 方法导出动画数据传递给组件的 animation 属性。

- animation
- 动画队列

### 绘图

#### wx.createCanvasContext
#### wx.canvasToTempFilePath
把当前画布的内容导出生成图片，并返回文件路径

### 置顶
wx.setTopBarText
### 窗口
wx.setWindowSize
wx.onWindowResize
wx.offWindowResize
## 网络

### 发起请求 wx.request({})
> 发起的是 HTTPS 请求

- url  开发者服务器接口地址
- data Object/String 请求的参数
- header    设置请求的 header, header 中 不能设置 Referer
- method  OPTIONS 、 GET 、 HEAD 、 POST 、 PUT 、 DELETE 、 TRACE
- dataType   默认为 json , 会尝试对响应的数据做一次JSON .parse 
- success  收到开发者服务器成功返回的回调函数, res={data :"开发者服务器返回的内容"}
- fail 接口调用失败的回调函数
- complete 接口调用结束的回调函数(调用成功、失败都会执行)

``` js
if (res.data.status == 1) {
    console.log(JSON.parse(res.data.data))
    temp_data = JSON.parse(res.data.data)
} else {
    wx.showToast({
        title: res.data.message,
        icon: "loading ",
        duration: 2000
    });
}
```

网络请求的 referer 是不可以设直的,格式固定为 https://servicewechat.com/{appid}/{version}/page-frame. html ,其中{ appid }为小程序的 appid, {version}为小程序的版本号,版本号为 0 时表示开发版 。


### 下载 
#### wx.downloadFile

>下载文件资源到本地

### 上传
#### wx.uploadFile
> 将本地资源上传到开发者服务器，通过 wx.chooseImage 的接口获取本地路径

- url 开发者服务器url
- filePath  要上传文件资源路径
- name 文件对应的key
- formData 其它额外 form data
- success/ fail/complete

> 注意：返回数据是 string 格式 ,需要 JSON.parse 转换

### WebSocket

WebSocket protocol 是 HTML5 一种新的协议,它实现了浏览器与服务器全双工通信( full-duple ) , 一开始的握手需要借助 HTTP 请求完成 。


#### wx.connectSocket  创建一个 WebSocket 连接
- url 开发者服务器接口地址必须是 WSS 协议 ,且域名必须是后台配置的合法域名
- data 请求的数据
- header
- method 有效值为: OPTIONS 、 GET 、 HEAD 、 POST 、 PUT 、 DELETE
- success, fail,complete

``` js
  wx.connectSocket({
            url: " test .php"
        })
        wx.onSocketOpen(function (res) {
            console.log(" WebSocket 连接巳打开!")
        })
        wx.onSocketError(function (res) {
            console.log(" WebSocket 连接打开失败, 请检查!")
        })
```

#### wx.onSocketOpen   监听 WebSocket 连接打开事件
#### wx.onSocketError  监听 WebSocket 错误
#### wx.sendSocketMessage  通过 WebSocket 连接发送数据
#### wx.onSocketMessage  监听 WebSocket 接受到服务器的消息事件
#### wx.closeSocket    关闭 WebSocket 连接
#### wx.onSocketClose  监听 WebSocket 关闭

### TCP
### UDP
## 媒体
小程序可以调用 微信实现 的从本地相册选择图片，或照相，还可以操作网络上的图片
### 图片

#### wx.chooseImage  从本地相册选择图片或使用相机拍照
- count 最多可以选择的图片张数，默认9
- sizeType  original 原图 , compressed 压缩图 , 默认两者都有
- sourceType album 从相册选图 , camera 使用相机 ,默认两者都有
- success

返回: res.tempFilePaths


####  wx.previewImage 预览图片 
- Todo ??? 不会用 

- current 当前显示的图片链接，不填则是 urls 的第一张
- urls 需要预览的图片链接列表


#### wx.getImageInfo 获取图片信息
- src 图片路径，可以是临时文件路径，存储文件路径，网络图片路径

返回
``` 
errMsg: "getImageInfo:ok"
height: 277
orientation: "up"
path: "http://tmp/swErkFuHE1EN7535caeb5c8cbd96705b85b470b29835.png"
type: "png"
width: 480
```

### 录音
#### wx.startRecord  开始录音
当主动调用 wx.stopRecord ，或者录音超过1分钟时自动结束录音，返回录音文件的临时文件路径 

> 文件的临时路径，在小程序本次启动期间有用，如需持久保存，需要主动调用 wx.saveFile

         
#### wx.stopRecord  主动调用停止录音

### 音频播放控制

##### wx.playVoice    开始播放语音
> 同时只能有一首音乐正在播放
- filePath 需要播放的语音文件的路径

##### wx.pauseVoice   暂停正在播放的语音
##### wx.stopVoice    结束播放语音

### 音乐播放控制

- wx.getBackgroundAudioPlayerState  获取音乐播放状态
- wx.playBackgroundAudio  播放音乐，同时只能有一首音乐正在播放
- wx.pauseBackgroundAudio 暂停播放音乐
- wx.seekBackgroundAudio  控制音乐播放进度
- wx.stopBackgroundAudio  停止播放音乐
- wx.onBackgroundAudioPlay  监听音乐播放
- wx.onBackgroundAudioPause 监听音乐暂停
- wx.onBackgroundAudioStop  监听音乐停止

### 音频组件控制

- wx.createAudioContext 创建并返回 audio 上下文 audioContext 对象

### 视频

#### wx.chooseVideo  拍摄视频或从手机相册中选视频，返回视频的临时文件路径

- sourceType  album 从相册选择 ，默认 ['album','camera']
- maxDuration 最长拍摄是按 ，最长60秒
- camera  front 为前置，back 为后置 ，默认 back

返回
- tempFilePath 
- duration 选定视频时长
- size 视频的数据量大小
- height
- width


### 视频组件控制

#### wx.createVideoContext  创建并返回 video 上下文 videoContext 对象
videoContext 通过 videoId 跟一个 video 组件绑定，通过它可以操作一个 video组件

videoContext 对象的方法列表:
- play 播放
- pause 暂停
- seek 跳转到指定位置，单位 秒
- sendDanmu 发送弹幕， danmu 包含两个属性 , text ，color


#### wx.chooseMedia 拍摄或从手机相册中选择图片或视频
- count	最多可以选择的文件个数，默认9
- mediaType ['image','video']  mix 文件类型
- sourceType ['album', 'camera']	图片和视频选择的来源
- maxDuration 拍摄视频最长拍摄时间，单位秒。时间范围为 3s 至 60s 之间
- sizeType 仅对 mediaType 为 image 时有效，是否压缩所选文件 ['original', 'compressed']
- camera

返回
- tempFiles 本地临时文件列表
- type 文件类型，有效值有 image 、video、mix

其中，tempFiles 为
- tempFilePath	本地临时文件路径 (本地路径)
- size	本地临时文件大小，单位 B
- duration	视频的时间长度
- height	视频的高度
- width	视频的宽度
- thumbTempFilePath	视频缩略图临时文件路径
- fileType	文件类型  image，video	

## 文件

### wx.saveFile 保存文件到本地
- tempFilePath 需要保存的文件的临时路径
- success  返回文件的保存路径 saveFilePath

> 本地文件存储的大小限制为 10M


### wx.getSavedFileList 获取本地已保存的文件列表

返回
- errMsg 接口调用结果
- fileList 文件列表 { filePath ,createTime,size}


### wx.getSavedFileInfo 获取本地文件的文件信息

### wx.removeSavedFile 删除本地存储的文件
- filePath 需要删除的文件路径

### wx.openDocument 新开页面打开文档，支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx

- filePath 文件路径, 可以通过 downFile 获得



## 数据缓存

### wx.setStorage   
> 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口

- key 本地缓存中的指定的 key
- data 需要存储的内容 

wx.setStorage({
key:"userinfo",
data: { name:"aming",age:"38"}
})


### wx.setStorageSync 
> 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口

### wx.getStorage  从本地缓存中异步获取指定 key 对应的内容
- key 本地缓存中指定的 key
- success  返回 res={data:key 对应的内容}


### wx.getStorageSync 从本地缓存中同步获取指定 key 对应的内容
### wx.getStorageInfo 异步获取当前 storage 的相关信息
### wx.getStorageInfoSync 同步获取当前 storage 的相关信息
### wx.removeStorage  从本地缓存中异步移除指定 key
### wx.removeStorageSync  从本地缓存中同步移除指定 key
### wx.clearStorage 清理本地数据缓存
### wx.clearStorageSync 同步清理本地数据缓存


## 位置

### wx.getLocation 获取当前的地理位置、速度
>当用户离开小程序后，此接口无法调用；当用户单击 "显示在聊天顶部"时，可以继续调用

- type 默认 wgs84，返回 GPS坐标 , gcj02返回可用于 wx.openLocation 的坐标 
- altitude 传入 true 会返回高度信息，由于获取高度需要较高精确度，会减慢接口返回速度
- isHighAccuracy 开启高精度定位
- highAccuracyExpireTime 高精度定位超时时间(ms)，指定时间内返回最高精度，该值3000ms以上高精度定位才有效果

返回参数
- latitude 纬度，范围为 -90~90 ，负数为南纬
- longitude 经度, 范围为 -180~180，负数为西经
- speed 速度 ，单位 m/s
- accuracy  位置的精确度
- altitude 高度，单位 m
- verticalAccuracy 垂直精度，单位 m（Android 无法获取，返回 0）
- horizontalAccuracy 水平精度，单位 m

### wx.chooseLocation 打开地图选择位置
- latitude
- longitude 目标地经度

返回 
- name 位置名称
- address 详细地址
- latitude
- longitude 目标地经度


### wx.openLocation 使用微信内置地图查看位置
- latitude
- longitude 目标地经度

 

### wx.createMapContext 创建并返回 map 上下文 mapContext 对象

## 设备

### 系统信息

#### wx.getSystemInfo 获取系统信息

返回 

- SDKVersion: "2.19.4"
- batteryLevel: 100
- benchmarkLevel: 1
- bluetoothEnabled: true
- brand: "devtools"
- cameraAuthorized: true
- deviceOrientation: "portrait"
- devicePixelRatio: 2
- enableDebug: true
- errMsg: "getSystemInfo:ok"
- fontSizeSetting: 16
- language: "zh_CN"
- locationAuthorized: true
- locationEnabled: true
- microphoneAuthorized: true
- model: "iPhone 5"  // 手机型号
- notificationAuthorized: true
- pixelRatio: 2  // 设备像素比
- platform: "devtools"
- safeArea: {top: 20, left: 0, right: 320, bottom: 568, width: 320, …}
- screenHeight: 568
- screenWidth: 320
- statusBarHeight: 20
- system: "iOS 10.0.1"
- version: "8.0.5"
- wifiEnabled: true
- windowHeight: 504  // 窗口宽度
- windowWidth: 320   //窗口高度

#### wx.getSystemInfoSync 获取系统信息同步接口

### 网络状态

####  wx.getNetworkType 获取网络类型

返回
- networkType: "wifi"    2g 、 3g 、4g、wifi 


### 重力感应

####  wx.onAccelerometerChange  监听重力感应数据，频率：5次/秒

### 罗盘

#### wx.onCompassChange  监听罗盘数据，频率：5次/秒

### 拨打电话

#### wx.makePhoneCall  拨打电话
- phoneNumber 需要拨打的电话号码


### 扫码

#### wx.scanCode 调起客户端扫码界面，扫码成功后返回对应的结果
- onlyFromCamera: false,
- scanType: ['qrCode(二维码)','barCode(一维码)','datamatrix(Data Matrix码)','pdf417(PDF417条码)'],

返回
- result 所扫码的内容
- scanType 所扫码的类型
- charSet	所扫码的字符集
- path	当所扫的码为当前小程序二维码时，会返回此字段，内容为二维码携带的 path
- rawData 原始数据，base64编码
 
- QR_CODE	二维码
- AZTEC	一维码
- CODABAR	一维码
- CODE_39	一维码
- CODE_93	一维码
- CODE_128	一维码
## 开放接口

### 登录

####  wx.login 
>获取登录凭证（code）进而换取用户登录态信息

"021O9T100yqvGN1RvP200RqDyI3O9T1C"

- timeout:10000, 超时时间，单位ms

返回
- code 

#### code 换取 session_key
用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 auth.code2Session，
使用 code 换取 openid、unionid、session_key 等信息

``` js

wx.login({
  success (res) {
    if (res.code) {
      //发起网络请求
      wx.request({
        url: 'https://example.com/onLogin',
        data: {
          code: res.code
        }
      })
    } else {
      console.log('登录失败！' + res.errMsg)
    }
  }
})
```

接口地址如下 
https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code

请求参数

- appid	小程序 appId
- secret 小程序 appSecret
- js_code 登录时获取的 code
- grant_type 授权类型，此处只需填写 authorization_code

返回值

- openid	用户唯一标识
- session_key	会话密钥
- unionid	用户在开放平台的唯一标识符，若当前小程序已绑定到微信开放平台帐号下会返回，详见 UnionID 机制说明。
- errcode	错误码

errcode 的合法值
- -1	系统繁忙，此时请开发者稍候再试	
- 0	请求成功	
- 40029	code 无效	
- 45011	频率限制，每个用户每分钟100次	
- 40226	高风险等级用户，小程序登录拦截 

#### 登录态维护
通过 wx.login() 获取到用户登录状态后，需要维护登录态。开发者注意不应该直接把 session_key, openid 等字段作为用户的标识或 session 的标识，而应该自己派发一个 session 登录态。对于开发者自己生成的 session，应该保证其安全性且不应该设置较长的过期时间。 session 派发到小程序客户端之后，可将其存储在 storage 上，用于后续通信使用。



#### 登录时序图
> wx.checkSession 检查登陆态是否过期
>调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期

``` js
wx.checkSession({
  success () {
    //session_key 未过期，并且在本生命周期一直有效
  },
  fail () {
    // session_key 已经失效，需要重新执行登录流程
    wx.login() //重新登录
  }
})

```

#### 用户数据的签名校验
> 为了确保开放接口返回用户数据的安全性,微信会对明文数据进行签名 。 开发者可以根据业务需要对数据包进行签名校验,确保数据的完整性 。

通过调用接口(如 wx.getUserlnfo )获取数据时,接口会同时返回 rawData 、 signature ,其中 signature=sha1(rawData+session_key) 。

开发者将 signature 、 rawData 发送到开发者服务器进行校验 。 服务器利用用户对应的 session_key 使用相同的算法计算出 签名 signature2 ,比对 signature 与 signature2 即可校验数据的完整性 


#### 加密数据解密算法
接口如果涉及敏感数据(如 openId 和 unionId)，接口的明文内容将不包含这些敏感信息。开发者如需获取敏感数据，要对接口返回的加密数据 进行对称解密.

- 对称解密使用的算法为 AES-128-CBC ,数据采用 PKCS#7 填充 。
- 对称解密的目标密文为 Base64_Decode( encryptedData) 。
- 对称解密密钥 aeskey=Base64_Decode( session_key), aeskey 是 16 字节 。
- 对称解密算法初始向量 iv 会在数据接口中返回 。

### 用户信息

#### wx.getUserInfo 获取用户信息，需要先调用 wx.login 
- withCredentials 是否带上登录态信息
- lang 显示用户信息的语言  en , zh_CN, zh_TW

返回
- userInfo 用户信息对象，不包含 openid 等敏感信息
- rawData 不包括敏感信息的原始数据字符串，用于计算签名
- signature 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息
- encryptedData 包括敏感数据在内的完整用户信息的加密数据
- iv 加密算法的初始向量
- cloudID 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据
``` json
{
  "openId": "OPENID",
  "nickName": "NICKNAME",
  "gender": GENDER,
  "city": "CITY",
  "province": "PROVINCE",
  "country": "COUNTRY",
  "avatarUrl": "AVATARURL",
  "unionId": "UNIONID",
  "watermark": {
    "appid":"APPID",
    "timestamp":TIMESTAMP
  }
}
```
小程序用户信息组件示例代码
``` html
<!-- 如果只是展示用户头像昵称，可以使用 <open-data /> 组件 -->
<open-data type="userAvatarUrl"></open-data>
<open-data type="userNickName"></open-data>
<!-- 需要使用 button 来授权登录 -->
<button wx:if="{{canIUse}}" open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo">授权登录</button>
<view wx:else>请升级微信版本</view>
```

``` js
Page({
  data: {
    canIUse: wx.canIUse('button.open-type.getUserInfo')
  },
  onLoad: function() {
    // 查看是否授权
    wx.getSetting({
      success (res){
        if (res.authSetting['scope.userInfo']) {
          // 已经授权，可以直接调用 getUserInfo 获取头像昵称
          wx.getUserInfo({
            success: function(res) {
              console.log(res.userInfo)
            }
          })
        }
      }
    })
  },
  bindGetUserInfo (e) {
    console.log(e.detail.userInfo)
  }
})
```

#### UnionID 机制说明
同一用户 ,对同一个微信开放平台下的不同应用, unionid 是相同的 

### 微信支付
#### wx.requestPayment 发起微信支付
> 发起微信支付。调用前需在小程序微信公众平台 -功能-微信支付入口申请接入微信支付

- timeStamp 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间
- nonceStr 随机字符串，长度为32个字符以下
- package 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=***
- signType 签名算法，应与后台下单时的值一致 MD5,HMAC-SHA256,RSA
- paySign 签名

### 模板消息
基于微信的通知渠道，微信为开发者提供了可以高效触达用户的模板消息能力,以便实现服务
的闭环井提供更佳的体验 。

#### 使用说明
获取模板 id , 登录 https://mp.weixin.qq.com 获取模板,如果没有合适的模板,可以申请添加新
模板,审核通过后可使用,详见模板审核说明

页面的<form >组件,当属性 report-submit 为 true 时,可以声明为需发模板消息 ,此时单
击按钮提交表单可以获取 formid ,用于发送模板消息 。 当用户完成支付行为,可以获取
prepay_id 用 于发 送模板消息 。

#### 调用接口下发模板消息
(1) 获取 access_token

https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET

- grant_type 获取 access_token ,填写 client credential
- appid 第三方用户唯一凭证
- secret 即 appsecret

返回
- access_token 获取到的凭证
- expires_in 凭证有效时间,单位:秒


(2) 发送模板消息
https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=ACCESSTOKEN

POST请求
- touser  接收者(用户)的 openid
- template_id 所有需下发的模板消息的id
- form_id  表单提交场景下,为 submit 事件带上 的 formld , 支付场景下,为本次支付的 prepay_id
- value 模板内容,不填则下发空模板
- color 字体颜色
- emphasis_keyword 模板需要放大的关键词,不填则默认无放大

### 客服消息

#### 接收消息和事件
> 设置→消息服务器
##### 文本消息
##### 图片消息
##### 进入会话事件
#### 发送客服消息
#### 临时素材接口
##### 获取临时素材
##### 新增临时素材

### 分享

#### Page.onShareAppMessage
- title 分享标题
- desc 分享描述
- path 分享路径，以 /开头的完整路径

#### 获取二维码
>通过后台接口可以获取小程序任意页面的二维码,扫描该二维码可以直接进入小程序对应的页面

https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN

POST 参数
- path 不能为空 ,最大长度 128 字节
- width 二维码的宽度  ，默认 430

{"path":"pages/index?index=1","width": 430}
>带参二维码只有 100000 个,请谨慎调用 


## 获取界面上的节点信息 wx.createSelectorQuery
>用于获取节点属性、样式、在界面上的位置等信息。
>最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

```js
 const query = wx.createSelectorQuery()
 query.select('#the-id').boundingClientRect(function(res){
   res.top // #the-id 节点的上边界坐标（相对于显示区域）
 })
 query.selectViewport().scrollOffset(function(res){
   res.scrollTop // 显示区域的竖直滚动位置
 })
 query.exec()
``` 

上述示例中， #the-id 是一个节点选择器，与 CSS的选择器相近但略有区别

在自定义组件或包含自定义组件的页面中，推荐使用 this.createSelectorQuery 来代替 ，这样可以确保在正确的范围内选择节点。


# 事件
> 事件是视图层到逻辑层的通信方式
## 事件类型 
### 冒泡事件
| 类型               | 触发条件                                                          |
|--------------------+-------------------------------------------------------------------|
| touchstart         | 手指触摸动作开始                                                  |
| touchmove          | 手指触摸后移动                                                    |
| touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                              |
| touchend           | 手指触摸动作结束                                                  |
| tap                | 手指触摸后马上离开                                                |
| longpress          | 手指触摸后，超过 350ms 再离开，如果指定此事件，tap 事件将不被触发 |
| longtap            | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）      |
| transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发         |
| animationstart     | 会在一个 WXSS animation 动画开始时触发                            |
| animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                        |
| animationend       | 会在一个 WXSS animation 动画完成时触发                            |
| touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                      |

### 非冒泡事件
>如form 的 submit ，input的 input ， scroll-view 的 scroll事件

## 屏幕旋转事件     
   js
    Page({
        onResize(res) {
            res.size.windowWidth // 新的显示区域宽度
            res.size.windowHeight // 新的显示区域高度
        }
    })
  

## 事件属性
   - capture-bind：捕获阶段触发。
   - capture-catch：捕获阶段触发，并中断事件，不再向下传播，即中断捕获阶段，并取消随后的冒泡阶段。
   - bind：冒泡阶段触发。
   - catch：冒泡阶段触发，并取消事件进一步向上冒泡。

## 事件详解

### 绑定并阻止事件冒泡 catch
    
### 互斥事件绑定 mut-bind
> 所有 mut-bind是“互斥”的，只会有其中一个绑定函数被触发。
> 同时，它完全不影响 bind 和catch 的绑定效果。

例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
=handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。

``` html
 <view id="outer" mut-bind:tap="handleTap1">
   outer view
   <view id="middle" bindtap="handleTap2">
     middle view
     <view id="inner" mut-bind:tap="handleTap3">
       inner view
     </view>
   </view>
 </view>
```

### 获取属性值 
 <view class='first' data-num="1024" data-name="张三">第一个view</view>
  const first = e.currentTarget.dataset.name,
 

## DOM 操作 (addclass removeclass)
```
<div class="{{color}}">
this.setData({
color:red
})
```

## 刷新页面
_this.onLoad()

## 视频处理
不建议同个页面使用多个video组件，建议不超过3个video，如果要实现video列表功能，请进行优化（image列表，选中时将image替换成video）
