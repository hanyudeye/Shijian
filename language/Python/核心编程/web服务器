TCP的十种状态(在两边的是状态)
客户机                 服务器
SYN_SENT             LISTEN
            SYN
                     SYN_RECV
            SYN+ACK
ESTABLISHED
            ACK
                     ESTABLISHED

FIN_WAIT1
            FIN
                     CLOSE_WAIT
            ACK
FIN_WAIT2            LAST_ACK
            FIN
TIME_WAIT
            ACK
                     CLOSED
CLOSED

TTL 在网络上经过的路由器的最大值，每经过一个，就减1
MSL 一个数据包在网络上的存活时间，一般是1到2分钟
从TIME)WAIT到CLOSED大概2MSL

listen的队列问题
listen(n) n 同时连接的个数，在linux中是不限制n的，所以linux大多是做服务器端的，因为同时连接的人很多

半连接：此时客户机只发送一次SYN

#############################
常见网络攻击
tcp半连接攻击
dns攻击
dns欺骗
arp攻击  中间人攻击

查看域名对应的ip地址
nslook baidu.com

联网步骤：
电话线(电信号)    调制解调器(猫)(网络信号)    路由器    电脑

NAT 网络地址转换器  集路由器，自动分配ip等功能与一身

路由器中保存了一张表，这张表记录了转换前的地址和进路由器转换后的地址，主机要访问服务器，先经过路由器，路由器将它的ip地址进行转换，并记录在表里，建立
映射关系，相当于一个代理功能，服务器返回回来的内容也是先经路由器，再给主机，外网的设备是无法直接访问内网的设备，原因就是没有内网的映射表。

公有ip 对外能上网的ip
私有ip 自己在局域上网的ip

############################################
服务器
并发服务器
并行服务器  当前的CPU数要远远大于任务数

cow 写时copy
能公用就公用，不用复制，浪费资源

单进程非堵塞服务器
web服务器使用多进程、多线程的原因：
如果没有多线程、多进程，那么任务就是单任务的，即在为一个顾客服务的时候，不能同时为其他顾客服务

如果是单线程服务器是非堵塞的，那么就可以持续不断的运行，给人一种多线程的感觉

select版 TCP服务器
select能够完成对一些套接字的检测 系统底层的方法
readable,writeable,exceptional = select(inouts, [ ], [ ] )
第一个参数：检测这个列表中的套接字是否可以收数据
第二个参数: 检测这个列表中的套接字可否发数据
第三个参数：检测这个列表中的套接字是否产生了异常
返回一个3元元组

select 是创建一个监听套接字，对于新连接的套接字进行监听，并将已存在套接字放到列表中，循环读取

select 良好的跨平台
select 最多能够监听的套接字是1024（32维是1024,64位为2048）

select 最多1024 轮询的方式进行检测 效率低，慢
poll 解决了套接字有上限的问题  轮询检测
epoll 没有1024的限制 事件通知机制，不是轮询  是自己主动修改

import sys
sys.stdin   标准输入  键盘
sys.stdout  标准输出  屏幕
sys.stderr  标准错误  屏幕
fileno()  找出表示对应的字母 文件描述符

先创建监听套接字
通过某些方式来检测，哪些套接字可以收发
epllo_list = epoll.poll()
对上面检测出来的套接字进行收发数据处理

epllo > select/poll > 单进程非阻塞

##############################################
协程 在一个线程里面把任务分成很多分来执行
多线程和多进程要来回切换程序，要保存数据，效率相对于协程稍低

计算密集型  需要占用大量CPU资源，用多进程，用多线程不行，JIL问题，始终都是一个核在工作
io密集型   需要网络功能，大量时间都在等待网络数据的到来，多线程和协程

协程的底层是生成器做的

greenlet实现协程
协程可以由开发者决定什么时间切换程序

gevent实现协程
gevent遇到耗时操作时，会主动交出执行权













