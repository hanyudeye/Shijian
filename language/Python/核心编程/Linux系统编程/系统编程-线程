## 线程实现多任务的方式
Threading对Tread做了封装

线程是进程里面真正来执行代码的东西
多个进程就是多个资源，进程是资源分配的单位，线程是CPU调度的单位，进程已经分配了资源模块，线程在里面运行

线程之间是相互不影响，多个线程在同一个函数中执行没有任何问题，但是资源是共享的

主进程要把子进程消耗的资源收回
僵尸进程：子进程已经结束，但是父进程并没有结束，在等着收回子进程所消耗的资源
孤儿进程：父进程已经结束了，但是子进程没有结束，之后1号进程为子进程收回其消耗资源
# 在linux操作系统中，0负责切换进程，1负责生进程

线程执行顺序 不确定 因为进程是有调度算法决定的，所以在进程中执行的子线程同样顺序不定
生成线程是按顺序生成的，但是调用取决于系统调度算法
# Python跨平台，因为安装环境本身屏蔽了底层硬件的差别，留给上层统一的接口。

多线程共享全局变量
线程和进程不一样，进程的资源是单独的，不共享数据，所以只能进程间通信，而线程运行是单独的，资源是共享的，是共享全局变量的
虽然线程不需要线程间通信，但是两个线程对同一个全局变量进行修改的时候会出现问题。
将列表当成实参传递给线程也可以

进程和线程之间的对比
进程：能够完成多任务，比如在一台电脑上能够同时运行多个qq
线程：能够完成多任务，比如一个qq中多个聊天窗口

# 原子操作(原子性)：要么不处理，一处理就处理到位

避免全局变量被修改的方式1：轮询 但是轮询操作效率并不高，因为轮询很占CPU资源
避免全局变量被修改的方式2：互斥锁
某个线程想要更改共享疏忽时，先将其锁定，此时资源的状态为锁定，其他线程不能更改；直到该线程释放资源，将需要的状态变成非锁定，其他的
线程才能再次锁定该资源，互斥锁保证了每次只有一个线程进行读写擦偶作，从而保证了多线程情况下数据的正确性

多线程对同一个资源操作时需要加锁，加的位置当然是越小越好，也就是说加锁之后，多线程变单线程，但是单线程一定锁的时候越短越好，所以在for循环里面
加锁也是可以的，但是上锁代码自然是越少越好，因为上锁多线程变单线程，程序反而慢了。
互斥锁使用的是通知机制

线程执行顺序，方向都是从上往下执行的，但是指向先后顺序不确定

线程中的局部变量是不共享的，两个不同的线程运行同一个函数，但是两者是互不相干的，各自是各自的线程，但是全局变量，共有的是共享的
现在和进程不同的是，进程连全局变量都是不共享的

## 死锁
双方所需资源都掌握在对方手中，各自等着对方先执行
解决死锁方法：
1）添加超时时间  mutex.acquire(blocking)  blocking 阻塞时间 过了这个时间就不上锁了
看门狗思想：过一段时间给一个变量加1，如果一段时间之后如果没加1，那么程序就自动重启。
2）银行家算法
设计程序时，考虑全面

同步应用
同步：就是协同步调，按照预定的先后次序进行运行
异步：将来谁要先执行，不知道，要执行的时候会通知程序执行

同步执行可以通过互斥锁来实现，在主线程中给2/3上锁，在第一个线程中给1上锁，给2解锁，然后2执行，给3解锁，这样就可以按顺序执行了。

## 生产者和消费者模式  解耦
在产生和使用之间用一个缓冲池，用来解决速度不一致的问题
耦合 越高越不好  程序之间的联系性
这个缓冲池  可以由队列来承担queue，也可以有由文件来承担，这个模式说到底就是使用进程中通信手段实现了个进程之间的通信，并且实现了解耦。
这个阻塞队列往往都是给生产者和消费者解耦用的

## 可以使用全局字典来给函数传参，一个一个传参，速度太慢，所以直接将参数放在全局字典里面，
全局字典有key，所以也不会出现参数混乱的问题
threading.local()  非常好，给他传的参数是跟着线程走的，不会因为下一份线程赋值而改变他随着线程跑的值

## 异步
没有先后顺序，你也不知道什么时候会发生
主进程正在做事，但是不确定什么时候主进程被打断去做事，如果子进程有返回值，此时在子进程执行完的基础上主进程是可以拿到子进程的返回值的
Ajax

# GIL 全局解释器锁
Python语言中的多线程是假的，线程中GIL保证每一时刻只有一个线程使用cpu，但是多进程不一样，所以在Python中，多进程效率要远高于多线程
库文件：程序编译成的0101的文件，分静态库和动态库，动态库是可能依赖于当前系统的
关键地方用C执行，效率很高，Python胶水语言，优势体现在这里




















