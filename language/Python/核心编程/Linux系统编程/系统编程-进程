################################################
pdb调试
l = list 显示当前的代码
n = next 向下执行一行代码
c = continue 继续执行代码

如果想让代码执行到固定为止的话，就要加断点
b = break 添加断点
clear = 删除断点

上述情况中要注意的是程序在执行函数语句的时候并不会返回到程序中去程序，而是直接执行
s = step 先指向这个函数，然后在进入函数再到函数里面一步一步运行
p = print 打印一个变量的值
a = args 打印所有的形参数据
q = quit 推出调试
r = return 快速执行到函数的最后一行

执行时调试：
python -m pdb 程序.py

交互调试：
import pdb
pdb.run('')

程序中调试
import pdb
在想要调试的地方加上,程序到这一句话的时候就会自动停下来
pdb.set_trace()

编码风格 pep8
python3中tab和空格不能混合使用
函数和函数之间用一个空行隔开，类与类之间用两个空行隔开，所以pycharm里面是标准的python写作风格
python默认编码就是utf-8，国际通用，gbk是国标的，utf-8是各国的文字编码都包含其中
导入模块顺序：标准库、第三方的、自己库，每个部分之间最好有一个空行

括号里面避免空格
逗号、冒号、分号之前避免空格
一行代码放两行语句，就要加分号
一般再等号两边加空格，关键字参数和默认值参数的前后不要加空格
不推荐复合语句

############################################
多任务
调度算法，子进程先还是主进程取决于调度算法，是相互交叉的
1.时间片轮转
2.优先级调度

并发：看上去是同时在执行，实际不是
并行：实际就是同时执行，5个核执行5个程序

进程的创建 - fork
注意：fork()这个函数在windows环境中是没有的，在linux、mac环境下才有这个函数
正在运行着的代码---进程

fork()返回值的大小是不确定的，不同设备运行不同程序返回值都是不同的
0是固定的，0就是子进程返回的值
os.getpid()获取当前子进程的id号
os.getppid()获取当前父进程的id值

一般64位的进程数是65531，这么多位是足够进程使用的
服务器相对单一，如果是web服务器只面向web使用，不会有太多的程序

父子进程的先后顺序问题
import os
import time
ret = os.fork()
if ret == 0:
    print('---子进程1---')
    time.sleep(5)
    print('---子进程over---')
else:
    print('---父进程---')
    time.sleep(3)
print('---进程完毕---')
父进程首先执行，结束之后程序结束，父进程不会理会子进程是否结束，以父进程为主，但是子进程也会自己接着执行
但是父子进程是互不干涉的

修改全局变量
多次fork()问题
fork炸弹 通过不断fork，占用cpu资源，直到服务器资源耗尽崩掉
while True：
    os.fork()

使用mutipeprocessing中的process创建子进程
使用fork()创建子进程，父进程和子进程之间是没有关系的，子进程节不结束与父进程无关，但是用Process创建子进程，父进程会等所有的子进程全部结束，
才会创建父进程

join()只有当子进程全部结束之后，主进程才从join继续执行
Python中[]是可写可不写的条件
terminate() 进程杀死

time.ctime()  当前的时间
time.time()  记录当前时间，是格林威治时间到目前的时间以秒计

通过继承父类也可以创建子进程

进程池

进程总结：
1.fork()是很底层的创建进程的方法，创建进程在底层都是fork()函数实现的，但是会向上不断封装
ret = os.fork()

2.创建的子进程和父进程都是可以干事的
p1 = Process(target = xxx)
p1.start()

3.进程池 主进程一般用来等待，真正的任务都是在子进程中执行的，但是进程数并不是越大越好
pool = Pool(3)
# 非堵塞
pool.apply_async()
# 堵塞,添加一个进程，执行一次，上次不执行完，下一个程序不写进去
pool.apply()

进程间通信 Queue队列
多任务的程序  可以通过不断新建管道来实现队列通信
进程池之间的通信  Manager().Queue()
进程与进程之间是没有关系的，通过进程间通信

案例：利用多进程进行下载任务，且用queuue进行信息传递











