如果你当前目录没有你想导入的的文件名，就先把路径导入
import sys
sys.path.append('  ')

如果当前路径下的文件修改了，你此时有正在运行改文件，那么此次修改你是看不出来效果的，使用reload()该文件才能看的出来效果
from imp import * 导入reload()

循环导入
不要出现这种情况，由主模块去调用其他子模块即可

== 是判断值是否相等
is 是判断引用是否相同
a=[11,22,33]  b=[11,22,33] a和b的值是相同的，但是a和b的引用地址，即id是不同的，所以==是True,但是is是False，不过这个False
是有范围的，在范围以内都是True

浅拷贝和深拷贝：
浅拷贝只是拷贝引用地址，也就是说如果你拷贝出来的仅仅只是一个指向内存地址的连接，而深拷贝拷贝的是一份内存地址，有不同过得id
import copy
c=copy.deepcopy()
而且深拷贝可以递归拷贝，就意味着即便原数据嵌套了好几层，也依然可以拷贝出来，而不只是一个只指向地址的连接
然而copy.copy在第一层拷贝可变类型时，是拷贝一份第一层的内存地址，但是嵌套的拷贝只是连接的拷贝，得到一份元数据的连接，当源数据改变时，当前拷贝的那份
也随之发生改变；在一层拷贝的是不可变数据类型时，比如元组，则只是拷贝第一层的链接，很好理解，因为不可变数据类型无法进行更改，拷贝一份
内存地址没有意义。

进制
2。。。。16进制

符号位采用第一位来表示，如果是正数，那么第一位就是1，如果是负数，那么第一位就是0，这样会带来一个问题，就是四则运算不对？
原码、反码、补码
规则： 正数：原码 = 反码 = 补码
      负数：反码 = 符号位不变，其他位取反
           补码 = 反码+1
为什么设计原码、反码、补码？
为了合理的四则运算，利用补码和补码那么就是可以得到正常的四则运算

从补码转回原码
正数就不谈了
负数补码   原码 = 补码的符号位不变->数据位取反->尾+1

十进制转二进制   bin(18)  0b开头表示二进制
十进制转8进制    oct(18)  0o开头表示8进制
十进制转16进制   hex(18)  0x开头表示16进制
其他进制转十进制  int('',多少进制数)

位运算
向左移一位相当于乘以2，向右移动一位相当于除以2
<< 按位左移
>> 按位右移
这种操作相较于*而言，效率更高
但是这种操作只能按偶数倍增加，如果是奇数倍，那么先乘偶数倍，再加上一倍即可
& 按位与 全1才1否则0
| 按位或 有1就1 只要对应的二个二进位有一个位1时，结果位就为1，否则为0
^ 按位异或 相同位就0.不同位就1
~ 取反 原来是1，取反位0
 
为什么9取反变成了-10?
为什么用9的补码？可能是因为补码在计算中用的最多吧。
用9的补码取反，然后再把补码返回来成可以识别的原码

私有化：
XX：公有变量
__私有化属性 __私有方法 在外部调用是不可以的，子类无法继承和使用
__XX__  而在python中凡是具有特殊功能，都是前后双下划线的
XX__  XX可以是某类关键字,这样就可以使用关键字做变量和方法
__X  使用from __ import * 是无法导入使用的  必须使用import __,然后使用XX._X才能使用 ，但是子类和类对象可以访问

name mangling： python通过名字重整就是防止子类意外重写基类的方法或者属性
但是私有属性事实上是可以访问的，通过对象名.属性名就可以访问，实际开发中并不是推荐这么做

property()  这是个属性方法，可以将getter和setter方法变成变量式的调用




















