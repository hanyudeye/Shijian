新式类使用广度优先的继承方式，就是在继承上先搜索上一级所有，旧式类是使用深度优先，先搜索一支，在继承上是搜索深度为主

类属性放在类的__dict__中，对象属性即self的属性就放在对象的__dict__中，先去__dict__中找，找不到再利用__getattr__方法
__getattr__(self,item)
__getattribute__(self,item)   #  搜索的前后顺序的和赋值行为，不能随意更改，有可能陷入死循环，函数自己调用自己

# 单词之间下划线

################################################
字符串处理
正则 描述规则的表达式
re模块
result = re.match(正则表达式，要匹配的字符串)
返回匹配对象，否则返回None（注意不是空字符串）

通用性规则的描述
match表示从左到右进行匹配
.   匹配任意1个字符
[]  匹配[]中列举的字符  1[2356]  16  加上[]表示第二位可以存放的数字，2356中任意一个数字都可以
\d  匹配数字，即0-9  ==[0-9]
\D  匹配非数字，即不是数字  ==[^0-9]
\s  匹配空白，即空格、tab键
\S  匹配非空白
\w  匹配单词字符，即a-z、A-Z、0-9、_  ==[^a-zA-Z0-9_]
\W  匹配费单词字符  ==[^^a-zA-Z0-9_]
使用格式：
import re
re.match('.','hello')
# 规则可以比后面字符串多，只要前面的规则是匹配的的就可以，但是少肯定不行的，匹配对不上了
re.match('1\d\d\d\d\d\d\d','12345678')
# 表示只要不是3456都是可以，满足要求的
re.match('1[^3456]','1a')
# 表示a到z，5到9都是满足条件的
re.match('1[a-z5-9]','')

表示数量
*  匹配前一个字符出现0次或者无限次，及可有可无
+  匹配前一个字符出现1次或者无限次，即至少出现一次
？  匹配前一个字符出现1次或者0次，即要么有一次，要么没有
{m} 匹配前一个字符出现m次
{m,} 匹配前一个字符至少出现m次
{m,n} 匹配前一个字符出现从m到n次
# 实例  匹配手机号
re.match('1[34578]\d{9}','18788834071')
# 比较有趣的例子
re.match('\d*','a')
这个函数返回的是空字符串，不是none，因为\d*表示的*前面的字符可以出现也可以不出现，但是\d时数字，后面接着的是一个字母，所以返回的是空字符串，返回none
则是规则错误，这个规则本身没问题，但是是不匹配的

'\nabc' 这个字符串正常的理解应该是换行abc，但是字符本身就是\n，而不是换行，则应该写成\\nabc，就是加倍\
s = r'\nabc'
r = raw 是原始数据的意思，避免被转义，如果是规则，那么本身确实是不需要转义的

表示边界
^  匹配字符串开头
$  匹配字符串结尾
\b 匹配一个单词的边界
\B 匹配费单词边界
例子 1.
re.match(r'^\w+\bve','hover')
re.match(r'^\w+\s\bve\b','hover')
re.match(r'^\w+\Bve\B','hover')

匹配分组
| 匹配左右任意一个表达式
(ab) 将括号中字符做一个分组    括号表示一种提取
\num 引用分组num匹配到的字符串
(?p<name>) 分组起别名
(?P=name) 引用别名为name分组匹配到的字符串

例子 2. 匹配0-100之间所有数
re.match(r'[1-9]\d?$|0$|100$','100')
re.match(r'[1-9]?$|100$'，'100')

result = re.match(r'<h1>(.*)</h1>','<h1>匹配分组</h1>')
result.group(1)

result = re.match(r'(<h1>).*(</h1>)','<h1>匹配分组</h1>')
# 默认就是0，0表示所有的字符
result.group()
# 1表示遇到第一个括号
group(1)
# 2表示遇到的第二个括号
group(2)

例子 3
匹配这个字符串
s = '<html><h1>hello</h1></html>'
# 第一种方法，上述形式并不是一定的，只要有这种形式的，都可以匹配
re.match(r'<.+><.+>.+</.+></.+>',s)
# 第二种方法，更具有普遍性，加上()之后，</\2>表示上面的第二个例子重复出现
re.match(r'<(.+)><(.+)>.+</\2></\1>',s)
# 第三种方法
re.match(r'<(?p<key1>.+)><(?p<key2>.+)>.+</(?p=key1)></(?p=key1)>,s)

例子 4 匹配邮箱
(1) P = r'(\w+)@(163|126|gmail|qq)\.(com|net|cn)$'  由于这个点在特殊意义，所以在前面加一个\是可以的
r = re.match(p,'leeguandon@gmail.com')
r.group()

re模块的高级用法
1.search用法,但是只拿到第一个就不拿了
s = '<html><h1>hello</h1></html>'
re.search(r'hello',s)
2.findall  拿到所有匹配的
3.sub将匹配到的数据进行替换
re.sub(r'php','python','hello cpp php python')  # 替换，php将第三个参数左右的字符串都替换成python
re.sub(r'\d+','50','python=1000,php=0')
返回 python=50，php=50
4.split分割字符串
re.split()

正则表达式都是贪婪模式  尽可能多的匹配
例子：s = 'This is a number 234-235-22-423'
r = re.match(r'.+(\d+-\d+-\d+-\d+)',s)
在贪婪模式下，结果是4-235-22-423，23放到前面去了
r = re.match(r'(.+?)(\d+-\d+-\d-\d+)',s)
加上？之后就关闭了贪婪模式，那么第一部分不贪婪了，第二部分还是贪婪模式的，所以要以第二部分尽可能贪婪为主，就是匹配的尽可能多为主，结果是234-235-22-423

notes: # 就是注释，python解释器不会理会，但是'''  '''是占内存空间的，不用的时候是会回收的，但是太大，会影响内存运行效率


