notes:不能光注重代码，中文记录要越详细越好，以后在面试的时候用的到
排序与搜索
排序算法是一种能将一串数据按照特定顺序进行排序的一种算法

排序算法的稳定性
稳定排序算法就让原本有相等键值的记录维持相对次序。
就是在第一排序之后，次序与原来顺序保持一致的就是稳定的

##################################
冒泡排序
最优时间复杂度：O(n)表示遍历一次没有发现任何可以交换的元素，排序结束
最坏时间复杂度：O(n^2)
稳定性：稳定

选择排序
从无序中找到最小的依次排序
选择排序是一种简单直观的排序算法。他的工作原理如下，首先在排序序列中找到最小的元素，存放到排序序列的起始位置，然后，再从剩余未排到
元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推
选择排序的主要优点与数据移动有关
最优时间复杂度：O(n^2)
最坏时间复杂度：O(n^2)
稳定性：不确定(考虑升序每次选择最大的情况)

插入排序
从后面选中一个，在前面进行排序，和选择是相反的，选择排序是选大小再排序，而插入排序是先选数，再排大小
最优时间复杂度：O(n) (升序排列，序列已经处于升序状态)
最坏时间复杂度：O(n^2)
稳定性：稳定

希尔排序
希尔排序是插入排序的一种，也成缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是把记录按下标的一定增量
分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减少至1时，整个文件掐被分成一组，算法被终止。
把原来一组分成多组，对每组使用插入排序，再合并，然后减少间隔数，在分组，在排序，再合并，以此类推，取好间隔的话，确实可以有效的降低时间复杂度
最有时间复杂度：根据步长序列的不同而不同
最坏时间复杂度：O(n^2)
稳定性：不稳定

快速排序
将第一个数存储起来，左右各一个指针，右边指针向左移动，由于第一个数被取出，首先移动右边指针，当数大于第一个数时，则向左移动，比第一个小的时候
就停下来，将这个数放到第一位，此时左边指针向右移动，遇到比第一个数小的数就持续向右移动，遇到比第一个数大的数就停下来，把这个数放到右边，开始右边指针移动，
以此类推，当两个指针重合时，此时就找到第一个数的位置了，此数两边，再各成一个子列进行上述操作
最优时间复杂度：O(nlogn) 在竖向上，是2^x = n,解出来x=logn，因为每次都会产生一倍，第一次产生了两个子列，逐渐对半，最后到每个元素只剩自身一个的时候终止，
但是总和依然是n，所以是logn，横向上一共是n，所以总和是n*logn
最坏时间复杂：竖向上每次都是第一个，那么有n个，横向上还是n，则是n*n
稳定性：不稳定，因为有跳跃取值，不像冒泡，冒泡之所以稳定，不存在跳跃取值。

notes:
1.传值进来是传的原来的列表，用切片相当于传进来一个新的列表，这肯定是不对的，最后的整体列表无法合成
2.自身递归

归并排序
归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组

将数据分解到最小之后，然后合并两个有序数组，基本思想是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，
直至一个数组为空，最后把另一个数组的剩余部分赋值过来即可

最优时间复杂度：O(nlogn)
最坏时间复杂度：O(nlogn)
稳定性：稳定
归并算法是涉及到额外的开销，这是和其他几种排序算法所不同的，但是归并算法确实可以有效的减少最坏时间复杂度

#########################################
排序算法总结

快速排序是应用很广泛的，是必须掌握的




